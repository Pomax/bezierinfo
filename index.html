<!doctype html>
<html>

  <head>
    <!-- referral tracking -->
    <script src="referrer.js"></script>

    <!-- page information -->
    <meta charset="utf-8">
    <title>Bézier curve framework</title>

    <!-- styling -->
    <link rel="stylesheet" media="screen" href="style.css">
    <link rel="stylesheet" media="print" href="print.css">

    <!-- JS API improvements -->
    <script>
      // give NodeList a .forEach() and .toArray(), because: seriously.
      (function(p,n,a,f,t){n=n[p];a=a[p];n[f]=a[f];n[t]=function(){var
        r=[];this[f](function(n){r.push(n);});return r;}}
      ("prototype",NodeList,Array,"forEach","toArray"));
    </script>

    <!-- opengraph information -->
    <meta property="og:title" content="A Primer on Bezier Curves">
    <meta property="og:type" content="text">
    <meta property="og:url" content="http://pomax.github.io/bezierinfo">
    <meta property="og:description" content="A detailed explanation of Bezier curves, and how to do the many things that we commonly want to do with them.">
    <meta property="og:locale" content="en_GB">
    <meta property="og:type" content="article">
    <meta property="og:published_time" content="2013-06-13 12:00:00">
    <meta property="og:author" content="Mike 'Pomax' Kamermans">
    <meta property="og:section" content="Bezier Curves">
    <meta property="og:tag" content="Bezier Curve">

    <!-- share button stuff -->
    <script src="socialite.min.js"></script>

    <!-- <link rel="component" href="webcomponents/github-components.html"> -->
  </head>

  <body>
    <!-- link out to the github repo for this article -->
    <a class="ribbon" href="http://github.com/pomax/bezierinfo"><img
      src="images/ribbon.png"
      alt="check the code on GitHub"
      title="check out the code on GitHub"
      border=0
    ></a>

    <!-- actual article -->
    <article>
      <header>
        <h1>A Primer on Bézier Curves</h1>
      </header>

      <section id="preface">
        <div id="navbar">
          <h3>Table of Contents</h3>
          <ol></ol>
          <ul id="sharebuttons">
            <!-- linkedin -->
            <li><a class="socialite linkedin-share">Share this on Linkedin</a></li>
            <!-- twitter -->
            <li><a class="socialite twitter-share" href="http://twitter.com/share" data-via="TheRealPomax"
                data-text="Reading up on Bezier Curves on" data-url="http://pomax.github.io/bezierinfo"
                data-dnt="true" data-count="none">Share on Twitter</a></li>
            <!-- facebook -->
            <li><a class="socialite facebook-like" data-href="http://pomax.github.io/bezierinfo"
                data-send="false" data-layout="button_count" data-width="450"
                data-show-faces="false">Like this on facebook</a></li>
            <!-- google -->
            <li><a class="socialite googleplus-share"data-size="medium" data-annotation="none"
                data-href="http://pomax.github.io/bezierinfo">Share this on Google+</a></li>
          </ul>
        </div>

        <p>In order to draw things in 2D, we usually rely on lines, which typically get classified
        in to categories: straight lines, and curves. The first of these are as easy to draw as they
        are easy to make a computer draw. Give a computer the first and last point in the line, and
        BAM! straight line. No questions asked.</p>

        <p>Curves, however, are a much bigger problem. While we can draw curves with ridiculous ease
        freehand, computers are a bit handicapped in that they can't draw curves unless there is a
        mathematical function that describes how it should be drawn. In fact, they even need this for
        straight lines, but the function is ridiculously easy, so we tend to ignore that as far as
        computers are concerned, all lines are "functions", regardless of whether they're straight
        or lines. However, that does mean that we need to come up with fast-to-compute functions that
        lead to nice looking curves on a computer. There's a number of these, and in this article
        we'll focus on a particular function that has received quite a bit of attention, and is used
        in pretty much anything that can draw curves: "Bézier" curves</p>

        <p>They're named after <a href="https://en.wikipedia.org/wiki/Pierre_B%C3%A9zier">Pierre
        Bézier</a>, who is principally responsible for getting them established as a curve well-suited
        for design work (publishing his investigations in 1962), although he did not "invent" them.
        That credit may actually go to mathematician <a href="https://en.wikipedia.org/wiki/Paul_de_Casteljau">Paul
        de Casteljau</a>, who investigated the nature of these curves in 1959 and came up with a really
        elegant way of figuring out how to draw them. Although, that said, one could argue that even
        that's not entirely correct: Bézier curves are, at their core, "Bernstein polynomials", a
        family of mathematical functions investigated by <a href="https://en.wikipedia.org/wiki/Sergei_Natanovich_Bernstein">Sergei Natanovich Bernstein</a>, with publications
        on them at least as far back as 1912. Anyway, that's mostly trivia, what you are more likely
        to care about is that these curves are handy: you can linked up multiple Bézier curves so
        that the combination looks like a single curve. If you've ever drawn Photoshop "paths" or
        worked with vector drawing programs like Flash, Illustrator or InkScape, those curves you've
        been drawing are Bézier curves.</p>

        <p>So, what if you need to program them yourself? What are the pitfalls? How do you draw them?
        What are the bounding boxes, how do you determine intersections, how can you extrude a curve,
        in short: how do you do everything that you might want when you do with these curves? That's
        what this page is for. Prepare to be mathed.</p>

        <h2 style="font-style:italic;">All Bézier graphics are interactive.</h2>

        <p>This page uses <a href="http://processing.org">Processing</a> examples, rendering as
        interactive graphics on the page using <a href="http://processingjs.org">Processing.js</a>,
        which means you don't need any plugins if you're on a modern browser. (If you
        are still using IE8 because you're on Windows XP, be aware Microsoft would rather you start
        using something like Firefox than keep using IE8, because IE8 does not support the internet
        anymore. It was already a little behind when it was first released, but today it literally
        doesn't support the internet, a bit like the difference between wordpad and Word. IE8 is
        no longer a web browser, it's a legacy application). It also uses math, in LaTeX form, which
        is typeset using the most excellent <a href="http://mathjax.org">MathJax</a> library.</p>

        <h2 style="font-style:italic;">Examples have a "view source" option.</h2>

        <p>Just seeing that the guy who wrote the article knows how to write the code needed to
        demonstrate Bezier curve things is basically useless, I think you'll agree. You don't benefit
        from me going: <em>"Look at me, I know how to program, ooooh~"</em>. So to make things <em>useful</em>,
        all graphics on this page have "view source" links. Click them, copy the source code, fire
        up the <a href="http://processing.org/download/">Processing PDE</a>, paste the code, and
        hit "play". You should see the exact same thing now running on your own computer as you're
        seeing in the browser. This is working code, and you can trace everything I do. Regardless
        of whether you <em>want</em> to, I consider it important that you can. And the kicker is
        this code is in the public domain. I waive all rights to it. Do with it what you want, to
        me this is trivial code and it would be ridiculous to claim it as anything other than "I
        just wrote this to demonstrate how things work".</p>

        <h2 style="font-style:italic;">Questions, comments:</h2>

        If you have suggestions for new sections, hit up the <a href="https://github.com/pomax/bezierinfo/issues">github
        issue tracker</a> (also reachable from the repo linked to in the upper right). If you have
        questions about the material, there's currently no comment section while I'm doing the rewrite,
        but you can use the issue tracker for that as well. Once the rewrite's done, I'll add a general
        comment section back in, and maybe a more topical "select this section of text and hit the
        'question' button to ask a question about it" system. We'll see.

        <p>—Pomax (or in the tweetworld, <a href="https://twitter.com/TheRealPomax">@TheRealPomax</a>)</p>

      </section>

      <section id="introduction">
        <h2 data-num="1">Introduction</h2>

        <p>Let's start with the good stuff: when we're talking about Bézier curves, we're talking about the
        things that you can see in the following graphics. They run from some start point to some end point,
        with their curvature influenced by one or more "intermediate" control points. Now, because all the
        graphics on this page are interactive, go manipulate those curves a bit: click-drag the points,
        and see how their shape changes based on what you do.</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Quadratic Bézier curves">
        void setupCurve() {
          setupDefaultQuadratic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Cubic Bézier curves">
        void setupCurve() {
          setupDefaultCubic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();
        }</textarea>

        <p>These curves are used a lot in computer aided design and computer aided manufacturing (CAD/CAM)
        applications, as well as in graphic design programs like Adobe Illustrator and Photoshop, Inkscape,
        the Gimp, etc. and in graphic technologies like scalable vector graphics (SVG) and OpenType fonts
        (ttf/otf). A lot of things use Bézier curves, so if you want to learn more about them... prepare
        to get your learn on!</p>
      </section>

      <section id="explanation">
        <h2>How do Bézier curves work?</h2>

        <p>Bézier curves are a form of "parametric" function. Mathematically speaking, parametric
        functions are cheats: a "function" is actually a well defined term representing a mapping
        from any number of inputs to a <strong>single</strong> output. Numbers go in, a single
        number comes out. Change the numbers that go in, and the number that comes out is still
        a single number. Parametric functions cheat. They basically say "alright, well, we want
        multiple values coming out, so we'll just use more than one function". An illustration:
        Let's say we have a function that maps some value, let's call it <i>x</i>, to
        some other value, using some kind of number manipulation:</p>

        <p>\[
          f(x) = \sin(x)
        \]</p>

        <p>The notation <i>f(x)</i> is the standard way to show that it's a function (by convention
        called <i>f</i> if we're only listing one) and its output changes based on one variable
        (in this case, <i>x</i>). Change <i>x</i>, and the output for <i>f(x)</i> changes.</p>

        <p>So far so good. Now, let's look at parametric functions, and how they cheat.
        Let's take the following two functions:</p>

        <p>\[\begin{matrix}
          f(a) = \sin(a) \\
          f(b) = \cos(b)
        \end{matrix}\]</p>

        <p>There's nothing really remarkable about them, they're just a sine and cosine function,
        but you'll notice the inputs have different names. If we change the value for <i>a</i>,
        we're not going to change the output value for <i>f(b)</i>, since <i>a</i> isn't used
        in that function. Parametric functions cheat by changing that. In a parametric function
        all the different functions share a variable, like this:</p>

        <p>\[
        \left \{ \begin{matrix}
          f_a(t) = \sin(t) \\
          f_b(t) = \cos(t)
        \end{matrix} \right. \]</p>

        <p>Multiple functions, but only one variable. If we change the value for <i>t</i>,
        we change the outcome of both <i>f<sub>a</sub>(t)</i> and <i>f<sub>b</sub>(t)</i>.
        You might wonder how that's useful, and the answer is actually prety simple: if
        we change the labels <i>f<sub>a</sub>(t)</i> and <i>f<sub>b</sub>(t)</i> with what
        we usually mean with them for parametric curves, things might be a lot more obvious:</p>

        <p>\[
        \left \{ \begin{matrix}
          x = \sin(t) \\
          y = \cos(t)
        \end{matrix} \right. \]</p>

        <p>There we go. <i>x</i>/<i>y</i> coordinates, linked through some mystery value <i>t</i>.</p>

        <p>So, parametric curves don't define a <i>y</i> coordinate in terms of an <i>x</i> coordinate,
        like normal functions do, but they instead link the values to a "control" variable.
        If we vary the value of <i>t</i>, then with every change we get <strong>two</strong> values,
        which we can use as (<i>x</i>,<i>y</i>) coordinates in a graph. The above set of functions,
        for instance, generates points on a circle: We can range <i>t</i> from negative to positive
        infinity, and the resulting (<i>x</i>,<i>y</i>) coordinates will always lie on a circle with
        radius 1 around the origin (0,0). If we plot it for <i>t</i> from 0 to 5, we get this:</p>

        <textarea class="sketch-code" data-sketch-preset="empty" data-sketch-title="A (partial) circle: x=sin(t), y=cos(t)">

        void drawFunction() {
          pushStyle();
          translate(dim/2,dim/2);
          stroke(150);
          line(-dim,0,dim,0);
          line(0,-dim,0,dim);

          stroke(0);
          float r = dim/3;
          for(float t=0; t<=5; t+=0.01) {
            point(r * sin(t), r * cos(t));
          }

          fill(0);
          for(float i=0; i<=5; i+=0.5) {
            ellipse(r*sin(i),r*cos(i),3,3);
            text("t="+i,r*sin(i)+10,r*cos(i));
          }

          fill(150);
          textAlign(CENTER,CENTER);
          text("0,0",-10,10);
          text("1",r+10,15);
          text("-1",-10,r+10);
          text("-1",-r-10,15);
          text("1",-10,-r-10);
          popStyle();
        }</textarea>

        <p>Bézier curves are (one in many classes of) parametric functions, and are characterised
        by using the same base function for all its dimensions. Unlike the above example,
        where the <i>x</i> and <i>y</i> values use different functions (one uses a sine, the other
        a cosine), Bézier curves use the "binomial polynomial" for both <i>x</i> and <i>y</i>.
        So what are binomial polynomials?</p>

        <p>You may remember polynomials from high school, where they're those sums that look like:</p>

        <p>\[
          f(x) = a \cdot x^3 + b \cdot x^2 + c \cdot x + d
        \]</p>

        <p>If they have a highest order term <i>x³</i> they're called "cubic" polynomials, if it's
        <i>x²</i> it's a "square" polynomial, if it's just <i>x</i> it's a line (and if there aren't
        even any terms with <i>x</i> it's not a polynomial!)</p>

        <p>Bézier curves are polynomials of <i>t</i>, rather than <i>x</i>, with the value for <i>t</i>
        fixed being between 0 and 1, with coefficients <i>a</i>, <i>b</i> etc. taking the "binomial"
        form, which sounds fancy but is actually a pretty simple description for mixing values:</p>

        <p>\[ \begin{align*}
          linear &= (1-t) + t \\
          square &= (1-t)^2 + 2 \cdot (1-t) \cdot t + t^2 \\
          cubic &= (1-t)^3 + 3 \cdot (1-t)^2 \cdot t + 3 \cdot (1-t) \cdot t^2 + t^3
        \end{align*} \]</p>

        <p>I know what you're thinking: that doesn't look too simple, but if we remove <i>t</i> and
        add in "times one", things suddenly look pretty easy. Check out these binomial terms:</p>

        <p>\[ \begin{align*}
          linear &= \hskip{2.5em} 1 + 1 \\
          square &= \hskip{1.7em} 1 + 2 + 1\\
          cubic &= \hskip{0.85em} 1 + 3 + 3 + 1\\
          hypercubic &= 1 + 4 + 6 + 4 + 1
        \end{align*} \]</p>

        <p>Notice that 2 is the same as 1+1, and 3 is 2+1 and 1+2, and 6 is 3+3... As you
        can see, each time we go up a dimension, we simply start and end with 1, and everything
        in between is just "the two numbers above it, added together". Now <i>that's</i> easy
        to remember.</p>

        <p>There's an equally simple way to figure out how the polynomial terms work:
        if we rename <i>(1-t)</i> to <i>a</i> and <i>t</i> to <i>b</i>, and remove the weights
        for a moment, we get this:</p>

        <p>\[ \begin{align*}
          linear &= a + b \\
          square &= a \cdot a + a \cdot b + b \cdot b \\
          cubic &= a \cdot a \cdot a + a \cdot a \cdot b + a \cdot b \cdot b + b \cdot b \cdot b\\
        \end{align*} \]</p>

        <p>It's basically just a sum of "every combination of <i>a</i> and <i>b</i>", progressively
        replacing <i>a</i>'s with <i>b</i>'s after every + sign. So that's actually pretty simple
        too. So now you know binomial polynomials, and just for completeness I'm going to show
        you the generic function for this:</p>

        <p>\[
          Bézier(n,t) = \sum_{i=0}^{n}
                        \underset{binomial\ term}{\underbrace{\binom{n}{i}}}
                        \cdot\
                        \underset{polynomial\ term}{\underbrace{(1-t)^{n-i} \cdot t^{i}}}
        \]</p>

        <p>And that's the full description for Bézier curves. Σ in this function indicates that this is
        a series of additions (using the variable listed below the Σ, starting at ...=<value> and ending
        at the value listed on top of the Σ). So, now we know what the base function(s) look(s) like,
        time to add in the magic that makes Bézier curves so special: control points.<p>
      </section>

      <section id="control">
        <h2>Controlling Bézier curvatures</h2>

        <p>Bézier curves are (like all "splines") interpolation funtions, meaning they take a set of
        points, and generate values somewhere "between" those points. (One of the consequences of this
        is that you'll never be able to generate a point that lies outside the outline for the control
        points, commonly called the "hull" for the curve. Useful information!). In fact, we can visualise
        how each point contributes to the value generated by the function, so we can see which points are
        important, where, in the curve.</p>

        <p>The following graphs show the interpolation functions for quadratic and cubic curves, with "S"
        being the strength of a point's contribution to the total sum of the Bézier function. Click or
        click-drag to see the interpolation percentages for each curve-defining point at a specific <i>t</i>
        value.</p>

        <p>Also shown is the interpolation function for a 15th order Bézier function. As you can see,
        the start and end point contribute considerably more to the curve's shape than any other point
        in the control point set.</p>

        <textarea class="sketch-code" data-sketch-preset="ratios" data-sketch-title="Quadratic interpolations">
        int order = 3;
        </textarea>

        <textarea class="sketch-code" data-sketch-preset="ratios" data-sketch-title="Cubic interpolations">
        int order = 4;
        </textarea>

        <textarea class="sketch-code" data-sketch-preset="ratios" data-sketch-title="15th order interpolations">
        int order = 15;
        </textarea>

        <p>If we want to change the curve, we need to change the weights of each point, effectively changing
        the interpolations. The way to do this is about as straight forward as possible: just multiply each
        point with a value that changes its strength. These values are conventionally called "Weights", and
        we can add them to our original Bézier function:</p>

        <p>\[
          Bézier(n,t) = \sum_{i=0}^{n}
                        \underset{binomial\ term}{\underbrace{\binom{n}{i}}}
                        \cdot\
                        \underset{polynomial\ term}{\underbrace{(1-t)^{n-i} \cdot t^{i}}}
                        \cdot\
                        \underset{weight}{\underbrace{w_i}}
        \]</p>

        <p>That looks complicated, but as it so happens, the "weights" are actually just the coordinate values
        we want our curve to have: for an <i>n<sup>th</sup></i> order curve, w<sub>0</sub> is our start coordinate,
        w<sub>n</sub> is our last coordinate, and everything in between is a controlling coordinate. Say we want
        a cubic curve that starts at (120,160), is controlled by (35,200) and (220,260) and ends at (220,40),
        we use this Bézier curve:</p>

        <p>\[
        \left \{ \begin{matrix}
          x = \underline{120} \cdot (1-t)^3 + \underline{35} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{220} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{220} \cdot t^3 \\
          y = \underline{160} \cdot (1-t)^3 + \underline{200} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{260} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{40} \cdot t^3
        \end{matrix} \right. \]</p>

        <p>Which gives us the curve we saw at the top of the article:</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Our cubic Bézier curve">
        void setupCurve() {
          setupDefaultCubic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();
        }</textarea>

        <p>What else can we do with Bézier curves? Quite a lot, actually. The rest of this article covers
        a multitude of possible operations and algorithms that we can apply, and the tasks they achieve.</p>
      </section>

      <section id="reordering">
        <h2>Lowering and elevating curve order</h2>

        <p>One interesting property of Bézier curves is that an <i>n<sup>th</sup></i> order curve can
        always be perfectly represented by an <i>(n+1)<sup>th</sup></i> order curve, by giving the
        higher order curve specific control points.</p>

        <p>If we have a curve with three points, then we can create a four point curve that exactly
        reproduce the original curve as long as we give it the same start and end points, and for
        its two control points we pick "1/3<sup>rd</sup> start + 2/3<sup>rd</sup> control" and
        "2/3<sup>rd</sup> control + 1/3<sup>rd</sup> end", and now we have exactly the same curve as
        before, except represented as a cubic curve, rather than a quadratic curve.</p>

        <p>The general rule for raising an <i>n<sup>th</sup></i> order curve to an <i>(n+1)<sup>th</sup></i>
        order curve is as follows (observing that the start and end weights are the same as the start and
        end weights for the old curve):</p>

        <p>\[
          Bézier(n+1,t) = \sum_{i=0}^{n+1}
                        \underset{binomial\ term}{\underbrace{\binom{n+1}{i}}}
                        \cdot\
                        \underset{polynomial\ term}{\underbrace{(1-t)^{n+1-i} \cdot t^{i}}}
                        \cdot
                        \underset{new\ weights}{\underbrace{\left ( \frac{i}{n+1} \cdot w_{i-1} + \frac{n+1-i}{n+1} \cdot w_i \right )}}
        \]</p>

        <p>However, this rule also has as direct consequence that you <strong>cannot</strong> generally
        safely lower a curve from <i>n<sup>th</sup></i> order to <i>(n-1)<sup>th</sup></i> order, because
        the control points cannot be "pulled apart" cleanly. We can try to, but the resulting curve will
        not be identical to the original, and may in fact look completely different.</p>

        <p>We can apply this to a (semi) random curve, as is done in the following graphic. Select the sketch
        and press your up and down cursor keys to elevate or lower the curve order.</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="A tenth order Bézier curve">
        void setupCurve() {
          int d = dim - 2*pad;
          int order = 10;
          ArrayList<Point> pts = new ArrayList<Point>();

          float dst = d/2.5, nx, ny, a=0, step = 2*PI/order, r;
          for(a=0; a<2*PI; a+=step) {
            r = random(-dst/4,dst/4);
            pts.add(new Point(d/2 + cos(a) * (r+dst), d/2 + sin(a) * (r+dst)));
            dst -= 1.2;
          }

          Point[] points = new Point[pts.size()];
          for(int p=0,last=points.length; p<last; p++) { points[p] = pts.get(p); }
          curves.add(new BezierCurve(points));
          reorder();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();
        }</textarea>
      </section>

      <section id="components">
        <h2>Component functions</h2>

        <p>One of the first things people run into when they start using Bézier curves in their own programs is
        "I know how to draw the curve, but how do I determine the bounding box?". It's actually reasonably straight
        forward to do so, but it requires having some knowledge on exploiting math to get the values we need.
        For bounding boxes, we aren't actually interested in the curve itself, but only in its "extremities": the
        minimum and maximum values the curve has for its x- and y-axis values. If you remember your calculus
        (provided you ever took calculus, otherwise it's going to be hard to remember) we can determine function
        extremities using the first derivative of that function, but this poses a problem, since our function is
        parametric: every axis has its own function.</p>

        <p>The solution: compute the derivative for each axis separately, and then fit them back together in the same
        way we do for the original.</p>

        <p>Let's look at how a parametric Bézier curve "splits up" into two normal functions, one for the x-axis and
        one for the y-axis. Note the left-most figure is again an interactive curve, without labeled axes (you
        get coordinates in the graph instead).  The center and right-most figures are the component fuctions for
        computing the x-axis value, given a value for <i>t</i> (between 0 and 1 inclusive), and the y-axis value,
        respectively.</p>

        <p>If you move points in a curve sideways, you should only see the middle graph change; likely, moving
        points vertically should only show a change in the right graph.</p>

        <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Quadratic Bézier curve components">
        void setupCurve() {
          setupDefaultQuadratic();
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();

          noAdditionals();
          usePanelPadding();

          nextPanel();
          drawAxes("t",0,1, "x",0,panelDim);
          BezierCurve x_only = curve.justX(dim-2*pad);
          x_only.draw();

          nextPanel();
          drawAxes("t",0,1, "y",0,panelDim);
          BezierCurve y_only = curve.justY(dim-2*pad);
          y_only.draw();
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Cubic Bézier curve components">
        void setupCurve() {
          setupDefaultCubic();
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();

          noAdditionals();
          usePanelPadding();

          nextPanel();
          drawAxes("t",0,1, "x",0,panelDim);
          BezierCurve x_only = curve.justX(dim-2*pad);
          x_only.draw();

          nextPanel();
          drawAxes("t",0,1, "y",0,panelDim);
          BezierCurve y_only = curve.justY(dim-2*pad);
          y_only.draw();
        }</textarea>
      </section>

      <section id="derivatives">
        <h2>Derivatives</h2>

        <p>There's a number of useful things that you can do with Bézier curves based on their derivative,
        and one of the more amusing observations about Bézier curves is that their derivatves are, in fact,
        also Bézier curves. In fact, the derivation of a Bézier curve is relatively straight forward, although
        we do need a bit of math. First, let's revisit our original Bézier curve description:</p>

        <p>\[
          Bézier(n,t) = \sum_{i=0}^{n}
                        \underset{binomial\ term}{\underbrace{\binom{n}{i}}}
                        \cdot\
                        \underset{polynomial\ term}{\underbrace{(1-t)^{n-i} \cdot t^{i}}}
                        \cdot\
                        \underset{weight}{\underbrace{w_i}}
        \]</p>

        <p>And now the function for a curve's derivative:</p>

        <p>\[
          Bézier'(n,t) = \sum_{i=0}^{k}
                        \underset{binomial\ term}{\underbrace{\binom{k}{i}}}
                        \cdot\
                        \underset{polynomial\ term}{\underbrace{(1-t)^{k-i} \cdot t^{i}}}
                        \cdot\
                        \underset{derivative\ weight}{\underbrace{k \cdot (w_{i+1} - w_i)}}
                        {\ },{\ }with{\ }
                        k = (n-1)
        \]</p>


        <p>What are the differences? In terms of the actual Bézier curve, virtually nothing!
        We lowered the order (rather than <i>n</i>, it's now <i>n-1</i>), but it's still the
        same Bézier function. The only real difference, as it turns out, is in how the weights
        change when we derive the curve's function. If we have four points A, B, C, and D, then
        the derivative will have three points, the second derivative two, and the third derivative
        one:</p>

        <p>\[ \begin{array}{l}
          B(n,t),    & n = 4, & w = \{A,B,C,D\} \\
          B'(n,t),   & k = n-1 = 3, & w' = \{A',B',C'\}    &= \{3 \cdot (B-A), {\ } 3 \cdot (C-B), {\ } 3 \cdot (D-C)\} \\
          B''(n,t),  & k = n-2 = 2, & w'' = \{A'',B''\}    &= \{2 \cdot (B'-A'), {\ } 2 \cdot (C'-B')\} \\
          B'''(n,t), & k = n-3 = 1, & w''' = \{A'''\} &= \{1 \cdot (B''-A'')\}
        \end{array} \]</p>

        <p>We can keep performing this trick for as long as we have more than one weight. Once
        we have one weight left, the next step will see <i>k = 0</i>, and the result of our
        "Bézier function" summation is zero, because we're not adding anything at all. As such,
        a quadratic curve has no second derivative, a cubic curve has no third derivative, and
        generalised: an <i>n<sup>th</sup></i> order curve has <i>n-1</i> derivatives.</p>

      </section>

      <section id="extremities">
        <h2>Finding extremities</h2>

        <p>Now that we understand (well, superficially anyway) the component functions, we can find the extremities of our
        Bézier curve by finding maxima and minima on the component functions, by solving the equasions B'(t) = 0 and B''(t) = 0.
        Although, in the case of quadratic curves there is no B''(t), so we only need to compute B'(t) = 0.</p>

        <p>The problem with this is that as the order of the curve goes up, we can't actually solve those equasions the normal
        way. We can't take the function, and then work out what the solutions are. Not to mention that even solving a third
        order derivative (for a fourth order curve) is already a royal pain in the backside. We need a better solution. We
        need numerical approaches.</p>

        <p>That's a fancy word for saying "rather than solve the function, treat the problem as a sequence of identical
        operations, the performing of which gets us closer and closer to the real answer". Finding solutions to any
        <i>f(t) = 0</i> is called "root finding", and there is a really nice numerical root finding algorithm, called
        the Newton-Raphson root finding method (yes, after <strong>that</strong> Newton).</p>

        <div class="note">
          <h2><a href="http://en.wikipedia.org/wiki/Newton-Raphson">Newton-Raphson</a> root finding</h2>

          <p>The Newton-Raphson approach consists of picking a value <i>t</i> (any will do), and getting the corresponding
          value at that <i>t</i> value. For normal functions, we can treat that value as a height. If the height is zero,
          we're done, we have found a root. If it's not, we take the tangent of the curve at that point, and extend
          it until it passes the x-axis, which will be at some new point <i>t</i>. We then repeat the procedure with this
          new value, and we keep doing this until we find our root.</p>

          <p>Mathematically, this means that for some <i>t</i>, at step <i>n=1</i>, we perform the following calculation
          until <i>f<sub>y</sub></i>(<i>t</i>) is zero, so that the next <i>t</i> is the same as the one we already have:</p>

          <p>\[
            t_{n+1} = t_n - \frac{f_y(t_n)}{f'_y(t_n)}
          \]</p>

          <p>(The wikipedia article has a decent animation for this process, so I'm not adding a sketch for that here)</p>

          <p>Now, this works well only if we can pick good starting points, and our curve is continuously differentiable
          and doesn't have oscillations. Glossing over the exact meaning of those terms, the curves we're dealing with
          conform to those constraints, so as long as we pick good starting points, this will work. So the question is:
          which starting points do we pick?</p>

          <p>As it turns out, Newton-Raphson is so blindingly fast, we don't really have to pick: we simply run the
          algorithm from <i>t=0</i> to <i>t=1</i> at small steps (say, 1/200<sup>th</sup>) and the result will be
          all the roots we want. Of course, this may pose problems for high order Bézier curves: 200 steps for a
          200<sup>th</sup> order Bézier curve is going to go wrong, but that's okay: there is no reason, ever, to
          use Bézier curves of orders higher than 10, let alone 100.</p>
        </div>

        <p>With this, we can determine the first and second derivative roots for our Bézier curves, and show them
        in our previous graphics:</p>

        <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Quadratic Bézier curve components">
        void setupCurve() {
          setupDefaultQuadratic();
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();

          noAdditionals();
          usePanelPadding();

          nextPanel();
          drawAxes("t",0,1, "x",0,panelDim);
          BezierCurve x_only = curve.justX(dim-2*pad);
          x_only.draw();

          stroke(255,0,0);
          float[] tx = x_only.getInflections();
          for(float t: tx) {
            if(t==0 || t==1) continue;
            Point p = x_only.getPoint(t);
            ellipse(p.x,p.y,5,5);
            line(p.x,p.y-3,p.x,0);
          }

          nextPanel();
          drawAxes("t",0,1, "y",0,panelDim);
          BezierCurve y_only = curve.justY(dim-2*pad);
          y_only.draw();

          stroke(255,0,255);
          float[] ty = y_only.getInflections();
          for(float t: ty) {
            if(t==0 || t==1) continue;
            Point p = y_only.getPoint(t);
            ellipse(p.x,p.y,5,5);
            line(p.x,p.y-3,p.x,0);
          }
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Cubic Bézier curve components">
        void setupCurve() {
          setupDefaultCubic();
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();

          noAdditionals();
          usePanelPadding();

          nextPanel();
          drawAxes("t",0,1, "x",0,panelDim);
          BezierCurve x_only = curve.justX(dim-2*pad);
          x_only.draw();

          stroke(255,0,0);
          float[] tx = x_only.getInflections();
          for(float t: tx) {
            if(t==0 || t==1) continue;
            Point p = x_only.getPoint(t);
            ellipse(p.x,p.y,5,5);
            line(p.x,p.y-3,p.x,0);
          }

          nextPanel();
          drawAxes("t",0,1, "y",0,panelDim);
          BezierCurve y_only = curve.justY(dim-2*pad);
          y_only.draw();

          stroke(255,0,255);
          float[] ty = y_only.getInflections();
          for(float t: ty) {
            if(t==0 || t==1) continue;
            Point p = y_only.getPoint(t);
            ellipse(p.x,p.y,5,5);
            line(p.x,p.y-3,p.x,0);
          }
        }</textarea>
      </section>

      <section id="boundingbox">
        <h2>Bounding boxes</h2>

        <p>If we have the extremities, and the start/end points, a simple for loop that tests for min/max values for
        x and y means we have the four values we need to box in our curve:

        <p id="bounds_p"><i>Computing the bounding box for a Bézier curve</i></p>
        <ol>
          <li>Find all <i>t</i> value(s) for the curve's x- and y-roots.</li>
          <li>Discard any <i>t</i> value that's lower than 0 or higher than 1, because Bézier curves only use the interval [0,1].</li>
          <li>Determine the lowest and highest value when plugging the values <i>t=0</i>, <i>t=1</i> and each of the found
          roots into the original functions: the lowest value is the lower bound, and the highest value is the upper
          bound for the bounding box we want to construct.</li>
        </ol>

        <p>Applying this approach to our previous root finding, we get the following bounding boxes (with curve
        extremites colored the same as in the root finding graphics):</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Quadratic Bézier bounding box">
        void setupCurve() {
          setupDefaultQuadratic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();

          stroke(255,0,0);
          BezierCurve x_only = curve.justX(dim-2*pad);
          float[] tx = x_only.getInflections();
          for(float t: tx) {
            if(t==0 || t==1) continue;
            Point p = curve.getPoint(t);
            ellipse(p.x,p.y,5,5);
          }

          stroke(255,0,255);
          BezierCurve y_only = curve.justY(dim-2*pad);
          float[] ty = y_only.getInflections();
          for(float t: ty) {
            if(t==0 || t==1) continue;
            Point p = curve.getPoint(t);
            ellipse(p.x,p.y,5,5);
          }

          drawBoundingBox(curve.generateBoundingBox());
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Cubic Bézier bounding box">
        void setupCurve() {
          setupDefaultCubic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();

          stroke(255,0,0);
          BezierCurve x_only = curve.justX(dim-2*pad);
          float[] tx = x_only.getInflections();
          for(float t: tx) {
            if(t==0 || t==1) continue;
            Point p = curve.getPoint(t);
            ellipse(p.x,p.y,5,5);
          }

          stroke(255,0,255);
          BezierCurve y_only = curve.justY(dim-2*pad);
          float[] ty = y_only.getInflections();
          for(float t: ty) {
            if(t==0 || t==1) continue;
            Point p = curve.getPoint(t);
            ellipse(p.x,p.y,5,5);
          }

          drawBoundingBox(curve.generateBoundingBox());
        }</textarea>

        <p>We can construct even nicer boxes by aligning them along our curve, rather than along the x- and y-axis,
        but in order to do so we first need to look at how aligning works.</p>
      </section>

      <section id="aligning">
        <h2>Aligning curves</h2>

        <p>While there are an incredible number of curves we can define by varying the x- and y-coordinates for
        the control points, not all curves are actually distinct. For instance, if we define a curve, and then
        rotate it 90 degrees, it's still the same curve, and we'll find its extremities in the same spots, just
        at different draw coordinates. As such, one way to make sure we're working with a "unique" curve is to
        "axis-align" it.</p>

        <p>Aligning also simplifies a curve's functions. We can translate (move) the curve so that the first
        point lies on (0,0), which turns our <i>n</i> term polynomial functions into <i>n-1</i> term functions.
        The order stays the same, but we have less terms. Then, we can rotate the curves so that the last point
        always lies on the x-axis, too, making its coordinate (...,0). This further simplifies the function for
        the y-component to an <i>n-2</i> term function. For instance, if we have a cubic curve such as this:</p>

        <p>\[
        \left \{ \begin{matrix}
          x = \underline{120} \cdot (1-t)^3 + \underline{35} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{220} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{220} \cdot t^3 \\
          y = \underline{160} \cdot (1-t)^3 + \underline{200} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{260} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{40} \cdot t^3
        \end{matrix} \right. \]</p>

        <p>Then translating it so that the first coordinate lies on (0,0), moving all <i>x</i> coordinates
        by -120, and all <i>y</i> coordinates by -160, gives us:</p>

        <p>\[
        \left \{ \begin{matrix}
          x = \underline{0} \cdot (1-t)^3 - \underline{85} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{100} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{100} \cdot t^3 \\
          y = \underline{0} \cdot (1-t)^3 + \underline{40} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{100} \cdot 3 \cdot (1-t) \cdot t^2 - \underline{120} \cdot t^3
        \end{matrix} \right. \]</p>

        <p>If we then rotate the curve so that its end point lies on the x-axis, the coordinates (integer-rounded
        for illustrative purposes here) become:</p>

        <p>\[
        \left \{ \begin{matrix}
          x = \underline{0} \cdot (1-t)^3 + \underline{85} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{12} \cdot 3 \cdot (1-t) \cdot t^2 - \underline{156} \cdot t^3 \\
          y = \underline{0} \cdot (1-t)^3 + \underline{40} \cdot 3 \cdot (1-t)^2 \cdot t - \underline{140} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{0} \cdot t^3
        \end{matrix} \right. \]</p>

        <p>If we drop all the zero-terms, this gives us:</p>

        <p>\[
        \left \{ \begin{array}{l}
          x = \underline{85} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{13} \cdot 3 \cdot (1-t) \cdot t^2 - \underline{156} \cdot t^3 \\
          y = \underline{40} \cdot 3 \cdot (1-t)^2 \cdot t - \underline{141} \cdot 3 \cdot (1-t) \cdot t^2
        \end{array} \right. \]</p>

        <p>We our original curve definition has been simplified considerably. The following graphics
        illustrate the result of aligning our example curves to the x-axis, with the cubic case using
        the coordinates that were just used in the example formulae:</p>


        <textarea class="sketch-code" data-sketch-preset="twopanel" data-sketch-title="Aligning a quadratic curve">
        void setupCurve() {
          setupDefaultQuadratic();
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();

          nextPanel();
          stroke(0);
          line(0,0,0,dim);

          stroke(0,50);
          translate(3*dim/4,dim/2);
          line(-3*dim/4,0,dim/4,0);
          line(0,-dim/2,0,dim/2);

          curve.align().draw(color(150));
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="twopanel" data-sketch-title="Aligning a cubic curve">
        void setupCurve() {
          setupDefaultCubic();
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();

          nextPanel();
          stroke(0);
          line(0,0,0,dim);

          stroke(0,50);
          translate(3*dim/4,dim/2);
          line(-3*dim/4,0,dim/4,0);
          line(0,-dim/2,0,dim/2);

          curve.align().draw(color(150));
        }</textarea>
      </section>

      <section id="tightbounds">
        <h2>Tight boxes</h2>

        <p>With our knowledge of bounding boxes, and curve alignment, We can now form the "tight" bounding box for
        curves. We first align  our curve, recording the translation we performed, "T", and the rotation angle we
        used, "R". We then determine the aligned curve's normal bounding box. Once we have that, we can map that
        bounding box back to our original curve by rotating it by -R, and then translating it by -T. We now have
        nice tight bounding boxes for our curves:</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Tight quadratic Bézier bounding box">
        void setupCurve() {
          setupDefaultQuadratic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();
          drawBoundingBox(curve.generateTightBoundingBox());
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Tight cubic Bézier bounding box">
        void setupCurve() {
          setupDefaultCubic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();
          drawBoundingBox(curve.generateTightBoundingBox());
        }</textarea>

        <p>These are, strictly speaking, not necessarily the tightest possible bounding boxes. It is possible to compute
        the optimal bounding box by determining which spanning lines we need to effect a minimal box area, but because
        of the parametric nature of Bézier curves this is actually a rather costly operation, and the gain in bounding
        precision is often not worth it. If there is high demand for it, I'll add a section on how to precisely compute
        the best fit bounding box, but the math is fairly grueling and just not really worth spending time on.</p>
      </section>

      <section id="pointvectors">
        <h2>Tangents and normals</h2>

        <p>If you want to move objects along a curve, or "away from" a curve, the two vectors you're most interested
        in are the tangent vector and normal vector for curve points. These are actually really easy to find. For
        moving, and orienting, along a curve we use the tangent, which indicates the direction travel at specific
        points, and is literally just the first derivative of our curve:</p>

        <p>\[
        \left \{ \begin{matrix}
          tangent_x(t) = d_x(t) = B'_x(t) \\
          tangent_y(t) = d_y(t) = B'_y(t)
        \end{matrix} \right. \]</p>

        <p>This gives us the directional vector we want. We can normalize it to give us uniform directional vectors
        (having a length of 1.0) at each point, and then do whatever it is we want to do based on those directions:</p>

        <p>\[
        \left \{ \begin{matrix}
          \hat{x}(t) = || d_x(t) ||
                     =\frac{tangent_x(t)}{ || tangent(t) || }
                     = \frac{B'_x(t)}{\sqrt{B'_x(t)^2 + B'_y(t)^2}} \\
          \hat{y}(t) = || d_y(t) ||
                     = \frac{tangent_y(t)}{ || tangent(t) || }
                     = \frac{B'_y(t)}{\sqrt{B'_x(t)^2 + B'_y(t)^2}}
        \end{matrix} \right. \]</p>

        <p>If we want to move away from the curve instead, perpendicular to the curve at some point <i>t</i>, we want
        the "normal" vector. This vector runs at a right angle to the direction of the curve, and is typically of lenght
        1.0, so all we have to do is rotate the normalized directional vector and we're done:</p>

        <p>\[
        \left \{ \begin{matrix}
          normal_x(t) = \hat{x}(t) \cdot \cos{\frac{\pi}{2}} - \hat{y}(t) \cdot \sin{\frac{\pi}{2}}\\
          normal_y(t) = \hat{x}(t) \cdot \sin{\frac{\pi}{2}} + \hat{y}(t) \cdot \cos{\frac{\pi}{2}}
        \end{matrix} \right. \]</p>

        <p>The following two graphics show the tangent and normal along a quadratic and cubic curve, with
        the direction vector coloured blue, and the normal vector coloured red.</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Quadratic Bézier tangents and normals">
        void setupCurve() {
          setupDefaultQuadratic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw(color(0,40));
          float t, d = 15;
          Point p, tg, n;
          for(int i=0; i<=10; i++) {
            t = i/10.0;
            p = curve.getPoint(t);
            tg = curve.getDerivativePoint(t).normalize();
            n = curve.getNormal(t);
            stroke(0,0,255);
            line(p.x, p.y, p.x+d*tg.x, p.y+d*tg.y);
            stroke(200,0,0);
            line(p.x, p.y, p.x+d*n.x, p.y+d*n.y);
            stroke(0);
            ellipse(p.x, p.y, 5, 5);
          }
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Cubic Bézier tangents and normals">
        void setupCurve() {
          setupDefaultCubic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw(color(0,40));
          float t, d = 15;
          Point p, tg, n;
          for(int i=0; i<=10; i++) {
            t = i/10.0;
            p = curve.getPoint(t);
            tg = curve.getDerivativePoint(t).normalize();
            n = curve.getNormal(t);
            stroke(0,0,255);
            line(p.x, p.y, p.x+d*tg.x, p.y+d*tg.y);
            stroke(200,0,0);
            line(p.x, p.y, p.x+d*n.x, p.y+d*n.y);
            stroke(0);
            ellipse(p.x, p.y, 5, 5);
          }
        }</textarea>
      </section>

      <section id="arclength">
        <h2>Arc length</h2>

        <p>How long is a Bézier curve? As it turns out, that's not actually an easy question, because the answer
        requires math that —much like root finding— cannot generally be solved the traditional way. If we
        have a parametric curve with <i>f<sub>x</sub>(t)</i> and <i>f<sub>y</sub>(t)</i>, then the length of the
        curve, measured from start point to some point <i>t = z</i>, is computed using the following seemingly
        straight forward (if a bit overwhelming) formula:</p>

        <p>\[
          \int_{0}^{z}\sqrt{f_x'(t)^2+f_y'(t)^2} dt
        \]</p>

        <p>or, more commonly written using leibnitz notation as:</p>

        <p>\[
          length = \int_{0}^{z}\sqrt{ \left (dx/dt \right )^2+\left (dy/dt \right )^2} dt
        \]</p>

        <p>This formula says that the length of a parametric curve is in fact equal to the <b>area</b> underneath a function that
        looks a remarkable amount like pythagoras' rule for computing the diagonal of a straight angled triangle. This sounds
        pretty simple, right? Sadly, it's far from simple... cutting straight to after the chase is over: for quadratic curves,
        this formula generates an <a href="http://www.wolframalpha.com/input/?i=antiderivative+for+sqrt((2*(1-t)*t*B+%2b+t^2*C)'^2+%2b+(2*(1-t)*t*E)'^2)&incParTime=true">unwieldy computation</a>,
        and we're simply not going to implement things that way. For cubic Bézier curves, things get even more fun, because there
        is no "closed form" solution, meaning that due to the way calculus works, there is no generic formula that allows you to
        calculate the arc length. Let me just repeat this, because it's fairly crucial: <strong><em>for cubic and higher Bézier curves,
        there is no way to solve this function if you want to use it "for all possible coordinates". It cannot be done.</em></strong>.</p>

        <p>So we turn to numerical approaches again. The method we'll look at here is the
        <a href="http://www.youtube.com/watch?v=unWguclP-Ds&feature=BFa&list=PLC8FC40C714F5E60F&index=1">Gauss
        quadrature</a>. This approximation is a really neat trick, because for any <i>n<sup>th</sup></i> degree polynomial
        it finds approximated values for an integral really efficiently. Explaining this procedure in length is way beyond
        the scope of this page, so if you're interested in finding out why it works, I can recommend the University of
        South Florida video lecture on the procedure, linked in this very paragraph. The general solution we're looking
        for is the following:</p>

        <p>\[
          \int_{-1}^{1}\sqrt{ \left (dx/dt \right )^2+\left (dy/dt \right )^2} dt
          ≃
          \left [ C_1 \cdot f\left(t_1\right)
                 \ +\ ...
                 \ +\ C_n \cdot f\left(t_n\right)
          \right ]
          =
          \sum_{i=1}^{n}{C_i \cdot f\left(t_i\right)}
        \]</p>

        <p>In plain text: "we can express the length either as an integral function, which we know we cannot always solve,
        or as an infinite sum of rectangular strips, approximated by using some finite but high number of strips
        (with widths <i>C<sub>1</sub></i> for the first strip, <i>C<sub>2</sub></i> for the second, etc., and
        with heights <i>f(t<sub>1</sub>)</i> for the first, <i>f(t<sub>2</sub>)</i> for the second, etc.)
        and then simply add up the areas for all strips.</p>

        <p>Since computing the area for a rectangle is just width times height, this second approach is computationally
        cheap, provided we can also cheaply come up with sensible values for those <i>C<sub>1</sub></i>, <i>C<sub>2</sub></i>,
        etc. A naive way is to simply create <i>n</i> strips all with the same width, but there is a far better way,
        using special values for <i>C</i> and <i>f(t)</i> depending on the value of <i>n</i>, which indicates how many
        strips we'll use.</p>

        <div class="note">

          <p>Note that one requirement for the approach we'll use is that the integral must run from -1 to 1. That's no good, because
          we're dealing with Bézier curves, and the length of a section of curve applies to values which run from 0 to "some
          value smaller than or equal to 1" (let's call that value <i>z</i>). Thankfully, we can quite easily transform any
          integral interval to any other integral interval, by shifting and scaling the inputs. Doing so, we get the
          following:</p>

          <p>\[\begin{array}{l}
            \int_{0}^{z}\sqrt{ \left (dx/dt \right )^2+\left (dy/dt \right )^2} dt
            \\
            ≃ \
            \frac{z}{2} \cdot \left [ C_1 \cdot f\left(\frac{z}{2} \cdot t_1 + \frac{z}{2}\right)
                                      + ...
                                      + C_n \cdot f\left(\frac{z}{2} \cdot t_n + \frac{z}{2}\right)
                              \right ]
            \\
            = \
            \frac{z}{2} \cdot \sum_{i=1}^{n}{C_i \cdot f\left(\frac{z}{2} \cdot t_i + \frac{z}{2}\right)}
          \end{array}\]</p>

          <p>That may look a bit more complicated, but the fraction involving <i>z</i> is a fixed number,
          so the summation, and the evaluation of the <i>f(t)</i> values are still pretty simple.</p>

          <p>So, what do we need to perform this calculation? For one, we'll need an explicit formula for <i>f(t)</i>,
          because that derivative notation is handy on paper, but not when we have to implement it. We'll also
          need to know what these <i>C<sub>i</sub></i> and <i>t<sub>i</sub></i> values should be. Luckily, that's
          less work because there are actually many tables available that give these values, for any <i>n</i>,
          so if we want to approximate our integral with only two terms (which is a bit low, really) then
          <a href="legendre-gauss.html">these tables</a> would tell us that for <i>n=2</i> we must use the following values:</p>

          <p>\[\begin{array}{l}
          C_1 = 1 \\
          C_2 = 1 \\
          t_1 = - \frac{1}{\sqrt{3}} \\
          t_2 = + \frac{1}{\sqrt{3}}
          \end{array}\]</p>

          <p>Which means that in order for us to approximate the integral, we must plug these values into the approximate
          function, which gives us:</p>

          <p>\[

          \int_{0}^{z}\sqrt{ \left (dx/dt \right )^2+\left (dy/dt \right )^2} dt
          ≃
          \frac{z}{2} \cdot \left [ f\left( \frac{z}{2} \cdot \frac{-1}{\sqrt{3}} + \frac{z}{2} \right)
                        + f\left( \frac{z}{2} \cdot \frac{1}{\sqrt{3}} + \frac{z}{2} \right)
                    \right ]
          \]</p>

          <p>We can program that pretty easily, provided we have that <i>f(t)</i> available, which we do,
          as we know the full description for the Bézier curve functions B<sub>x</sub>(t) and B<sub>y</sub>(t).</p>
        </div>

        <p>So, with this information we can determine the approximate length of a Bézier curve by computing the
        Legendre-Gauss sum. The following graphic show a cubic curve, with its computed lengths, but the sketch
        allows curve order elevation and lowering.</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Arc length for a Bézier curve">
        void setupCurve() {
          setupDefaultCubic();
          reorder();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();
          pushStyle();
          fill(0);
          float f = curve.getCurveLength();
          if (f<0) {
            curves.clear();
            curves.add(curve.lower());
            redraw();
            return;
          }
          f = int(1000*f)/1000;
          text("curve length: "+f+"px", 15, 15);
          popStyle();
        }</textarea>
      </section>

      <section id="tracing">
        <h2>Tracing a curve at fixed distance intervals</h2>

        <p>Say you want to draw a curve with a dashed line, rather than a solid line,
        or you want to move something along the curve at fixed distance intervals over
        time, like a train along a track, and you want to use Bézier curves. Now you
        have a problem.</p>

        <p>The reason you have a problem is that Bézier curves are parametric functions
        with non-linear behaviour, whereas moving a train along a track is about as
        close to a practical example of linear behaviour as you can get. The problem
        we're faced with is that we can't just pick <i>t</i> values at some fixed interval
        and expect the Bézier functions to generate points that are spaced a fixed distance
        apart. In fact, let's look at the relation between "distance long a curve" and
        "<i>t</i> value", by plotting them against one another.</p>

        <p>The following graphic shows a particularly illustrative curve, and it's length/<i>t</i>
        plot. While the curve itself is a cubic curve, the plot shows that the distance function
        along the curve is actually a function of a much higher order than the curve itself.</p>

        <textarea class="sketch-code" data-sketch-preset="twopanel" data-sketch-title="The t-for-distance function">
        HashMap<Float,Float> values = new HashMap<Float,Float>();
        ArrayList<Float> keys = new ArrayList<Float>();

        void setupCurve() {
          curves.add(new BezierCurve( new Point[]{
            new Point(150,140),
            new Point(215,35),
            new Point(25,275),
            new Point(145,160)
          }));
        }

        float lD=0, D, d, x, y;
        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();
          D = curve.getCurveLength();

          noAdditionals();
          usePanelPadding();
          nextPanel();
          drawAxes("t",0,1, "d",0,D);

          if(lD!=D) {
            lD = D;
            values.clear();
            keys.clear();
            for(float t=0.001; t<=1.0; t+=0.001) {
              d = comp.getArcLength(t, curve.x_values, curve.y_values);
              x = map(t,0,1,0,panelDim);
              y = map(d,0,D,0,panelDim);
              values.put(x,y);
              keys.add(x);
            }
          }

          stroke(100);
          for(float x: keys) {
            point(x, values.get(x));
          }
        }</textarea>

        <p>We see a function that might be invertible, but we won't be able to do so, symbolically.
        You may remember from the section on arc length that we cannot actually compute the true
        arc length function as an expression of <i>t</i>, which means we also can't compute the true
        inverted function that gives <i>t</i> as an expression of length. So how do we fix this?</p>

        <p>One way is to do what the graphic does: simply run through the curve, determine its
        <i>t</i>-for-length values as a set of discrete values at some high resolution (the graphic
        uses 1000 discrete points), and then use those as a basis for finding an appropriate <i>t</i>
        value, given a distance along the curve. This works quite well, actually, and is fairly fast
        (you can move the curve around without noticable lag on a 2 year old computer, for instance).</p>

        <p>We can use some color to show the difference between distance-based and time based intervals:
        the following graph is similar to the previous one, except it segments the curve in terms of
        equal-distance intervals. This shows as regular color intervals going down the graph, but
        the mapping to <i>t</i> values is not linear, so there will be (highly) irregular intervals
        along the horizontal axis. It also shows the curve in an alternating coloring based on the
        t-for-distance values we find our LUT:</p>

        <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Fixed-interval coloring a curve">
        HashMap<Float,Float> values = new HashMap<Float,Float>();
        HashMap<Float,Float> inverted = new HashMap<Float,Float>();
        ArrayList<Float> t_keys = new ArrayList<Float>();
        ArrayList<Float> d_keys = new ArrayList<Float>();

        void setupCurve() {
          curves.add(new BezierCurve( new Point[]{
            new Point(150,140),
            new Point(215,35),
            new Point(25,275),
            new Point(145,160)
          }));
        }

        float lD=0, D, d, x, y;
        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();
          D = curve.getCurveLength();
          float section = 15;

          noAdditionals();
          usePanelPadding();
          nextPanel();
          drawAxes("t",0,1, "d",0,D);

          if(lD!=D) {
            lD = D;
            // clear everything
            values.clear();
            inverted.clear();
            t_keys.clear();
            d_keys.clear();
            // rebuild;
            for(float t=0.001; t<=1.0; t+=0.001) {
              d = comp.getArcLength(t, curve.x_values, curve.y_values);
              values.put(t,d);
              inverted.put(d,t);
              t_keys.add(t);
              d_keys.add(d);
            }
          }

          float x, y, ly=0;

          ArrayList<Float> markers = new ArrayList<Float>();
          color lc=0, c;
          for(float d: d_keys) {
            y = int(map(d,0,D,0,panelDim));
            x = map(inverted.get(d),0,1,0,panelDim);
            if(y%section==0 && ly != y) {
              ly = y;
              stroke(0,0,200,100);
              line(0,y,x,y);
              stroke(0,100,0,100);
              line(x,0,x,y);
              markers.add(inverted.get(d));
            }
          }

          stroke(0);
          for(float t: t_keys) {
            x = map(t,0,1,0,panelDim);
            y = map(values.get(t),0,D,0,panelDim);
            point(x, y);
          }

          nextPanel();
          additionals();
          curve.draw();
          noAdditionals();
          for(int m=1, last=markers.size(); m<last; m++) {
            BezierCurve segment = curve.split(markers.get(m-1), markers.get(m));
            color c = (m%2==0 ? color(155) : color(0,0,255));
            segment.draw(c);
          }

        }</textarea>

        <p>However, are there better ways? One such way is discussed in "<a href="http://www.geometrictools.com/Documentation/MovingAlongCurveSpecifiedSpeed.pdf"
        >Moving Along a Curve with Specied Speed</a>" by David Eberly of Geometric Tools, LLC, but
        basically because we have no explicit lengh function (or rather, one we don't have to
        constantly compute for different intervals), you may simply be better off with a traditional
        lookup table (LUT).</p>

        <p>That said, this is an area of Bézier curves that I've not really investigated in any
        depth, so if you think I'm missing something obvious and think I should have a look at
        [<i>whatever thing you think I need to have a look at</i>], get in touch and I shall
        try to update this section with new information.</p>
      </section>

      <section id="intersections">
        <h2>Intersections</h2>

        <p>Let's look at some more things we will want to do with Bézier curves. Almost immediately after figuring out how to
        get bounding boxes to work, people tend to run into the problem that even though the minimal bounding box (based on
        rotation) is tight, it's not sufficient to perform collision dectection ("<i>does curve C touch, or pass through, curve
        or line L?</i>"). In order to do this, we need to know whether or not there's an intersection on the actual curve.</p>

        <p>We'll do this in steps, because it's a bit of a journey to get to curve/curve intersection checking. First, let's
        start simple, by implementing a line-line intersection checker. While we can solve this the traditional calculus way
        (determine the functions for both lines, then compute the intersection by equating them and solving for two unknowns),
        linear algebra actually offers a nicer solution:</p>

        <p id="intersection_ll">if we have two line segments with two coordinates each, segments A-B and C-D, we can find the
        intersection of the lines these segments are an intervals on by linear algebra, using the procedure outlined in this
        <a href="http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=geometry2#line_line_intersection">top coder</a> article.
        Of course, we need to make sure that the intersection isn't just on the lines our line segments lie on, but also on our
        line segments themselves, so after we find the intersection we need to verify it lies without the bounds of our original
        line segments.</p>

        <p>The following graphic implements this intersection detection, showing a red point for an intersection on the lines
        our segments lie on (thus being a virtual intersection point), and a green point for an intersection that lies on
        both segments (being a real intersection point).</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Line/line intersections">
        Point p1, p2, p3, p4;

        void setupCurve() {
          p1 = new Point(50,50);
          p2 = new Point(150,110);
          curves.add(new BezierCurve(new Point[]{p1,p2}, false));
          p3 = new Point(50,250);
          p4 = new Point(170,170);
          curves.add(new BezierCurve(new Point[]{p3,p4}, false));
        }

        void drawCurve(BezierCurve curve) {
          // draw the lines through p1/p2 and p3/p4
          stroke(0,50);
          float dx = 10*(p2.x-p1.x), dy = 10*(p2.y-p1.y);
          line(p1.x-dx,p1.y-dy,p2.x+dx,p2.y+dy);
          dx = 10*(p4.x-p3.x); dy = 10*(p4.y-p3.y);
          line(p3.x-dx,p3.y-dy,p4.x+dx,p4.y+dy);

          // show the line segments
          curves.get(0).draw();
          curves.get(1).draw();

          // show the intersection point
          Point ntr = comp.getProjection(p1,p2,p3,p4);

          // red if virtual intersection, green if real
          boolean oncurves = true;
          if(min(p1.x,p2.x) > ntr.x || ntr.x > max(p1.x,p2.x) ||
             min(p1.y,p2.y) > ntr.y || ntr.y > max(p1.y,p2.y)) oncurves = false;
          if(oncurves) {
            if(min(p3.x,p4.x) > ntr.x || ntr.x > max(p3.x,p4.x) ||
              min(p3.y,p4.y) > ntr.y || ntr.y > max(p3.y,p4.y)) oncurves = false; }

          stroke(oncurves?0:255, oncurves?255:0, 0);
          ellipse(ntr.x,ntr.y,5,5);
        }</textarea>

        <p>Curve/line intersection is more work, but we've already seen the techniques we need to use in order
        to perform it: first we translate/rotate both the line and curve together, in such a way that the line
        coincides with the x-axis. This will position the curve in a way that makes it cross the line at
        points where its y-function is zero. By doing this, the problem of finding intersections between a
        curve and a line has now become the problem of performing root finding on our translated/rotated curve.
        One Newton-Raphson root finding round later and the intersections have been found:</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Quadratic curve/line intersections">
        Point p1, p2;

        void setupCurve() {
          p1 = new Point(40,60);
          p2 = new Point(260,200);
          curves.add(new BezierCurve(new Point[]{
            p1, p2
          }, false));
          curves.add(new BezierCurve(new Point[]{
            new Point(25,150),
            new Point(180,30),
            new Point(230,250)
          }));
        }

        void drawCurve(BezierCurve curve) {
          curves.get(0).draw();
          curves.get(1).draw();

          BezierCurve aligned = curves.get(1).align(p1,p2);
          float[] roots = comp.findAllRoots(0, aligned.y_values);
          fill(150,0,150);
          float x, y;
          for(float t: roots) {
            if(t<0 || t>1) continue;
            x = curves.get(1).getXValue(t);
            y = curves.get(1).getYValue(t);
            ellipse(x,y,5,5);
            text(""+round(1000*t)/1000,x+10,y);
          }
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Cubic curve/line intersections">
        Point p1, p2;

        void setupCurve() {
          p1 = new Point(100,20);
          p2 = new Point(195,255);
          curves.add(new BezierCurve(new Point[]{
            p1, p2
          }, false));
          curves.add(new BezierCurve(new Point[]{
            new Point(150,125),
            new Point(40,30),
            new Point(270,115),
            new Point(145,200)
          }));
        }

        void drawCurve(BezierCurve curve) {
          curves.get(0).draw();
          curves.get(1).draw();

          BezierCurve aligned = curves.get(1).align(p1,p2);
          float[] roots = comp.findAllRoots(0, aligned.y_values);
          fill(150,0,150);
          float x, y;
          for(float t: roots) {
            if(t<0 || t>1) continue;
            x = curves.get(1).getXValue(t);
            y = curves.get(1).getYValue(t);
            ellipse(x,y,5,5);
            text(""+round(1000*t)/1000,x+10,y);
          }
        }</textarea>

        <p>Curve/curve intersection, however, is more complicated. Since we have no straight line to align to, we
        can't simply align one of the curves and be left with a simple procedure. Instead, we'll need to apply two
        techniques we've not covered yet: de Casteljau's algorithm, and curve splitting.</p>
      </section>

      <section id="decasteljau">
        <h2>de Casteljau's algorithm</h2>

        <p>This algorithm is the basis for drawing arbitrarily complex Bézier curves. It's really straight forward:</p>

        <ul>
          <li>treat <i>t</i> as a ratio (which it is). t=0 is 0% along a line, t=1 is 100% along a line.</li>
          <li>Take all lines between the curve's defining points. For an order <i>n</i> curve, that's <i>n</i> lines.</li>
          <li>Place markers along each of these line, at distance <i>t</i>. So if <i>t</i> is 0.2, place the mark
              at 20% from the start, 80% from the end.</li>
          <li>Now form lines between <i>those</i> points. This gives <i>n-1</i> lines.</li>
          <li>Place markers along each of these line at distance <i>t</i>.</li>
          <li>Form lines between <i>those</i> points. This'll be <i>n-2</i> lines.</li>
          <li>place markers, form lines, place markers, etc.</li>
          <li>repeat this until you have only one line left. The point <i>t</i> on that line coincides with the
              original curve point at <i>t</i>.</li>
        </ul>

        <p>To see this in action, click the following sketch. This sketch has a curve that can be lowered and elevated,
        and will show de Casteljau's "skeleton" around the curve, showing how it's determining where to draw the curve's
        point for every <i>t</i> value. To pause or resume, simply click or hit space bar (when focussed on the sketch).</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Traversing a curve using de Casteljau's algorithm">
        void setupCurve() {
          //setupDefaultCubic();
          Point[] points = {
            new Point(65,25),
            new Point(5,150),
            new Point(80,290),
            new Point(220,235),
            new Point(250,150),
            new Point(135,125),
          };
          curves.add(new BezierCurve(points));
          reorder();
          animate();
          pause();
          span();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();
          Point p = curve.getPoint(t);
          ellipse(p.x, p.y, 5, 5);
          drawSpan(curve, t);
        }</textarea>
      </section>

      <section id="splitting">
        <h2>Splitting curves</h2>

        <p>With de Casteljau's algorithm we also find all the points we need to split up a Bézier curve into two, smaller
        curves, which taken together form the original curve. When we construct de Casteljau's skeleton for some value
        <i>t</i>, the procedure gives us all the points we need to split a curve at that <i>t</i> value: one curve is defined
        by all the inside skeleton points found prior to our on-curve point, with the other curve being defined by all the
        inside skeleton points after our on-curve point.</p>

        <p>This is best illustrated with an animated graphic:</p>

        <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Bézier curve splitting. Curve order can be lowered/elevated.">
        void setupCurve() {
          setupDefaultCubic();
          reorder();
          animate();
          pause();
          span();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();
          Point p = curve.getPoint(t);
          ellipse(p.x, p.y, 5, 5);
          drawSpan(curve, t);

          BezierCurve[] segments = curve.split(t);
          usePanelPadding();

          nextPanel();
          drawAxes("first curve x",0,panelDim, "first\ncurve\ny",0,panelDim);
          drawSpan(curve, t);
          segments[0].draw();

          nextPanel();
          drawAxes("second curve x",0,panelDim, "second\ncurve\ny",0,panelDim);
          drawSpan(curve, t);
          segments[1].draw();
        }</textarea>
      </section>

      <section id="curveintersection">
        <h2>Curve/curve intersection</h2>

        <p>Using de Casteljau's algorithm to split the curve we can now implement curve/curve intersection
        finding using a "divide and conquer" technique: take two curves <i>C<sub>1</sub></i> and <i>C<sub>2</sub></i>,
        and treat them as a pair. If their bounding boxes overlap, split up each curve into two subcurves,
        <i>C<sub>1.1</sub></i>, <i>C<sub>1.2</sub></i>, <i>C<sub>2.1</sub></i> and <i>C<sub>2.2</sub></i>,
        and form four new pairs (<i>C<sub>1.1</sub></i>,<i>C<sub>2.1</sub></i>), (<i>C<sub>1.1</sub></i>,
        <i>C<sub>2.2</sub></i>), (<i>C<sub>1.2</sub></i>,<i>C<sub>2.1</sub></i>), and (<i>C<sub>1.2</sub></i>,
        <i>C<sub>2.2</sub></i>). If their bounding boxes do not overlap, discard the pair, as there is no
        intersection between this pair of curves. If there was overlap, for each of the newly formed pairs,
        perform the same evaluation. Once the subcurves we form are so small that they effectively occupy
        sub-pixel areas, we consider an intersection found.</p>

        <p>This algorithm will start with a single pair, "balloon" until it runs in parallel for a large
        number of potential subpairs, and then taper back down as it homes in on intersection coordinates,
        ending up with as many pairs as there are intersections.</p>

        <p>The following graphic applies this algorithm to a pair of cubic curves, slowed down so that
        you can see the algorithm in action. Click the button to run the algorithm, after setting up
        your curves in some creative arrangement: <button id="clippingButton">detect</button></p>

        <textarea class="sketch-code" data-sketch-preset="clipping" data-sketch-title="Curve/curve intersections">
        void iterate() {
          if(pairs.size()==0) {
            iterated = false;
            drawResult();
            noAnimate();
            return; }

          fill(0);
          text("iteration "+(iterationCount++), 10,20);

          newPairs.clear();
          for(CurvePair cp: pairs) {
            cp.draw(getColor(random(999)));
            if(cp.hasOverlap()) {
              if(cp.smallEnough()) { finals.add(cp); }
              else {
                CurvePair[] expanded = cp.splitAndCombine();
                for(CurvePair ncp: expanded) {
                  newPairs.add(ncp);
                }
              }
            }
          }
          pairs.clear();
          for(CurvePair cp: newPairs) { pairs.add(cp); }
        }
        </textarea>

        <p>Self-intersection is dealt with in the same way, except we turn a curve into two or more curves first
        based on the inflection points. We then form all possible curve pairs with the resultant segments, and
        run exactly the same algorithm. All non-overlapping curvepairs will be removed after the first iteration,
        and the remaining steps home in on the curve's self-intersection points.</p>
      </section>

      <section id="moulding">
        <h2>Curve moulding (using the projection ratio)</h2>

        <p>De Casteljau's algorithm is the pivotal algorithm when it comes to Bézier curves. You can use it not just to split
        curves, but also to draw them efficiently (especially for high-order Bézier curves), as well as to come up with curves
        based on three points and a tangent. Particularly this last thing is really useful because it lets us "mould" a curve,
        by picking it up at some point, and dragging that point around to change the curve's shape.</p>

        <p>How does that work? Succinctly: we run de Casteljau's algorithm in reverse!</p>

        <p>Let's start out with a pre-existing curve, defined by <i>start</i>, two control points, and <i>end</i>. We can
        mould this curve by picking a point somewhere on the curve, at some <i>t</i> value, and the moving it to a new
        location and reconstructing the curve that goes through <i>start</i>, our new point with the original tangent,
        and </i>end</i>. In order to see how and why we can do this, let's look at some identity information for Bézier
        curves. There's actually a hidden goldmine of identities that we can exploit when doing Bézier operations, and
        this will only scratch the surface. But, in a good way!</p>

        <p>In the following graphic, click anywhere on the curves to see the identity information that we'll
        be using to run de Casteljau in reverse:</p>

        <textarea class="sketch-code" data-sketch-preset="abc" data-sketch-title="Projections in a quadratic Bézier curve">
        void setupCurve() {
          setupDefaultQuadratic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();

          if(Bt != -1) {
            Point[] abc = curve.getABC(Bt);
            drawABC(curve, abc);
          }
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="abc" data-sketch-title="Projections in a cubic Bézier curve">
        void setupCurve() {
          setupDefaultCubic();
        }

        void drawCurve(BezierCurve curve) {
          curve.draw();

          if(Bt != -1) {
            Point[] abc = curve.getABC(Bt);
            drawABC(curve, abc);
          }
        }</textarea>

        <p>So, what exactly do we see in these graphics? First off, there's the three points <i>A</i>, <i>B</i> and
        <i>C</i>.</p>

        <p>Point <i>B</i> is our "on curve" point, A is the first "strut" point when running de Casteljau's
        algorithm in reverse; for quadratic curves, this happens to also be the curve's control point. For cubic
        curves, it's the "top of the triangle" for the struts that lead to point <i>B</i>. Point
        <i>C</i>, finally, is the intersection of the line that goes through <i>A</i> and <i>B</i> and the baseline,
        between our start and end points.</p>

        <p>There is some important identity information here: as long as we don't pick a new <i>t</i> coordinate,
        the location of point <i>C</i> on the line <i>start-end</i> represents a fixed ratio distance. We can drag
        around the control points as much as we like, that point won't move at all, and if we can drag around
        the start or end point, C will stay at the same ratio-value. For instance, if it was located midway between
        start and end, it'll stay midway between start and end, even if the line segment between start and end
        becomes longer or shorter.</p>

        <p>We can also see that the distances for the lines <i>d1 = A-B</i> and <i>d2 = B-C</i> may vary, but the
        ratio between them, <i>d1/d2</i>, is a constant value. We can drag any of the start, end, or control points
        around as much as we like, but that value also stays the same.</p>

        <div class="note">
          <p>In fact, because the distance ratio is a fixed value for each point <i>B</i>, which we get by picking
          some <i>t</i> value on our curve, the distance ratio is actually an identity function for Bézier curves.
          If we were to plot all the ratio values for all possible <i>t</i> values for quadratic and cubic curves,
          we'd see two very interesting functions: asymptotic at <i>t=0</i> and <i>t=1</i>, tending towards positive
          infinity, with a zero-derivative minimum at <i>t=0.5</i>.</p>

          <p>Since these are ratios, we can actually express the ratio values as a function of <i>t</i>. I actually
          failed at coming up with the precise functions, but thanks to some help from
          <a href="http://mathoverflow.net/questions/122257/finding-the-formula-for-Bézier-curve-ratios-hull-point-point-baseline">Boris
          Zbarsky</a> we can see that the ratio functions are actually remarkably simple:</p>

          <table style="width:100%; border:0"><tr><td>
            <p>Quadratic curves:\[
              ratio(t)_2 = \left | \frac{2t^2 - 2t}{2t^2 - 2t + 1} \right |
            \]</p>
          </td><td>
            <p>Cubic curves: \[
              ratio(t)_3 = \left | \frac{t^3 + (1-t)^3}{t^3 + (1-t)^3 - 1} \right |
            \]</p>
          </td></tr></table>

          <p>Unfortunately, this trick only works for quadratic and cubic curves. Once we hit higher order curves,
          things become a lot less predictable; the "fixed point <i>C</i>" is no longer fixed, moving around as we
          move the control points, and projections of <i>B</i> onto the line between start and end may actually
          lie on that line before the start, or after the end, and there are no simple ratios that we can exploit.</p>
        </div>

        <p>So, with this knowledge, let's change a curve's shape by click-dragging some part of it. The follow
        graphics let us click-drag somewhere on the curve, repositioning point <i>B</i> according to a simple
        rule: we keep the original point <i>B</i>'s tangent, because while we're free to assign our new point
        any tangent we like, coming up with an aesthetically pleasing new tangent is probably material for an
        entire paper on curve design.</p>

        <p>Quadratic and cubic Bézier curves have a nice property that allows curve moulding (picking
        a point on the curve and changing the curve shape by moving it around), based on the fact that
        there is always a line {A,C} through the on-curve point B, where C lies on the baseline (the
        line between the curve's start and end coordinates) and the ratio between distance d1 = A-B
        and d2 = B-C is fixed. The following to sketches illustrate this line and the three points
        involved: click-drag on the curves to see this visualised.</p>

        <textarea class="sketch-code" data-sketch-preset="moulding" data-sketch-title="Moulding a quadratic Bézier curve">
        void setupCurve() {
          setupDefaultQuadratic();
          mould();
          span();
          additionals();
        }

        void mouldCurve(BezierCurve curve, int mx, int my) {
          if(Bt != -1) {
            B = new Point(mx, my);
            BezierCurve newcurve = comp.generateCurve(curve.order, curve.points[0], B, curve.points[curve.order], Bt);
            curves.clear();
            curves.add(newcurve);
          }
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="moulding" data-sketch-title="Moulding a cubic Bézier curve">
        void setupCurve() {
          setupDefaultCubic();
          mould();
          span();
          additionals();
        }

        void mouldCurve(BezierCurve curve, int mx, int my) {
          if(Bt != -1) {
            B = new Point(mx, my);
            BezierCurve newcurve = comp.generateCurve(curve.order, curve.points[0], B, curve.points[curve.order], Bt, tangents);
            curves.clear();
            curves.add(newcurve);
          }
        }</textarea>
      </section>

      <section id="Curves from points">
        <h2>Creating a curve from three points</h2>

        <p>Given the preceding section on curve moulding, we can also generate quadratic and cubic
        curves from any three points. However, unlike circle-fitting, which requires only three points,
        Bézier curve fitting requires three points, as well as a tangent and <i>t</i> value. We can
        come up with "default" values, where the <i>t</i> value for our middle point is simply 0.5,
        and the tangent is identical to the baseline for quadratic curves, or half the baseline for
        cubic curves.</p>

        <p>Using these "default" values for curve creation, we can already get fairly respectable
        curves; Click three times on each of the following sketches to set up the points
        that shoule be used to form a quadratic and cubic curve, respectively</p>

        <textarea class="sketch-code" data-sketch-preset="generate" data-sketch-title="Fitting a quadratic Bézier curve">
        void setupCurve() { span(); }

        void drawCurve(BezierCurve curve) {
          recordPoint(mouseX,mouseY);
          if(p1!=null) { p1.draw(); }
          if(p2!=null) { p2.draw(); }
          if(p3!=null) { p3.draw(); }
          if(p1!=null && p2!=null && p3!=null) {
            BezierCurve c = comp.generateCurve(2, p1, p2, p3);
            c.draw();
          }
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="generate" data-sketch-title="Fitting a cubic Bézier curve">
        void setupCurve() { span(); }

        void drawCurve(BezierCurve curve) {
          recordPoint(mouseX,mouseY);
          if(p1!=null) { p1.draw(); }
          if(p2!=null) { p2.draw(); }
          if(p3!=null) { p3.draw(); }
          if(p1!=null && p2!=null && p3!=null) {
            BezierCurve c = comp.generateCurve(3, p1, p2, p3);
            c.draw();
          }
        }</textarea>

        <p>(There are many ways to determine a combination of <i>t</i> and tangent values that lead
        to a more "aesthetic" curve, but this will be left as an exercise, since there are too many,
        and aesthetics are a personal choice)</p>
      </section>

      <section id="polybezier">
        <h2>Forming poly-Bézier curves</h2>

        <p>Much like lines can be chained together to form polygons, Bézier curves can be chained together
        to form poly-Béziers, and the only trick required is to make sure that: A) the end point of each
        section is the starting point of the following section, and B) the derivatives across that
        dual point line up. Unless, of course, you want discontinuities; then you don't even need (B).</p>

        <p>We'll cover three forms of poly-Bézier curves in this section. First, we'll look at the kind
        that enforces "the outgoing derivative is the same as the incoming derivative" across sections:</p>

        <p>\[
          B'(1)_n = B'(0)_{n+1}
        \]</p>

        <p>We can actually guarantee this really easily, because we know that the vector from a curve's
        last control point to its last on-curve point is equal to the derivative vector. If we want to
        ensure that the first control point of the next curve matches that, all we have to do is mirror
        that last control point through the last on-curve point. And mirroring any point A through any
        point B is really simple:</p>

        <p>\[
          Mirrored = (B_x + (B_x - A_x),\  B_y + (B_y - A_y) = (2B_x - A_x,\  2B_y - A_y)
        \]</p>

        <p>So let's implement that and see what it gets us. The following two graphics show a quadratic
        and a cubic poly-Bézier curve; both consist of multiple subcurves, but because of our constraint,
        not all points on the curves can be moved around freely. Some points, when moved, will move other
        points by virtue of changing the curve across sections.</p>

        <textarea class="sketch-code" data-sketch-preset="poly" data-sketch-title="Forming a quadratic poly-Bézier">
        void setupCurve() {
          setupDefaultQuadraticPoly();
        }

        void movePoint(int pt, int mx, int my) {
            p.movePointConstrained(pt, mx, my);
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="poly" data-sketch-title="Forming a cubic poly-Bézier">
        void setupCurve() {
          setupDefaultCubicPoly();
        }

        void movePoint(int pt, int mx, int my) {
            p.movePointConstrained(pt, mx, my);
        }</textarea>

        <p>As you can see, quadratic curves are particularly ill-suited for poly-Bézier curves, as all
        the control points are effectively linked. Move one of them, and you move all of them. This means
        that we cannot use quadratic poly-Béziers for anything other than really, really simple shapes.
        And even then, they're probably the wrong choice. Cubic curves are pretty decent, but the fact
        that the derivatives are linked means we can't manipulate curves as well as we might if we
        relaxed the constraints a little.</p>

        <p>So: let's relax them!</p>

        <p>We can change the constraint so that we still preserve the angle of the derivatives across
        sections (so transitions from one section to the next will still look natural), but give up
        the requirement that they should also have the same vector length. Doing so will give us
        a much more a useful kind of poly-Bézier curve:</p>

        <textarea class="sketch-code" data-sketch-preset="poly" data-sketch-title="A half-constrained quadratic poly-Bézier">
        void setupCurve() {
          setupDefaultCubicPoly();
        }

        void movePoint(int pt, int mx, int my) {
            p.movePointHalfConstrained(pt, mx, my);
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="poly" data-sketch-title="A half-constrained cubic poly-Bézier">
        void setupCurve() {
          setupDefaultCubicPoly();
        }

        void movePoint(int pt, int mx, int my) {
            p.movePointHalfConstrained(pt, mx, my);
        }</textarea>

        <p>Quadratic curves are still silly, but cubic curves are now much more controllable.</p>

        <p>If we want even more control, we could just abandon the derivative constraints entirely,
        and simply assure that the end point of one section is the same as the start point of the next section,
        and then keep it at that. This gives us the greatest degree of freedom when it comes to modeling
        shapes, but also means that our poly-Bézier constructs are no longer continuous curves. Sometimes
        this is exactly what you want (because it lets you add corners to a shape, while still only using
        Bézier curves).</p>

        <textarea class="sketch-code" data-sketch-preset="poly" data-sketch-title="An unconstrained quadratic poly-Bézier">
        void setupCurve() {
          setupDefaultCubicPoly();
        }

        void movePoint(int pt, int mx, int my) {
          p.movePoint(pvt, mx, my);
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="poly" data-sketch-title="An unconstrained cubic poly-Bézier">
        void setupCurve() {
          setupDefaultCubicPoly();
        }

        void movePoint(int pt, int mx, int my) {
          p.movePoint(pvt, mx, my);
        }</textarea>

        <p>When doing any kind of modeling, you generally don't want a poly-Bézier that will only let you
        pick one of the three forms for all your points; most graphics applications that deal with Bézier
        curves will actually let you pick, per on-curve point, how to deal with the control points around it:
        fully constrained, loosely constrained, or completely unconstrained. The best shape modeling comes
        from having a curve that will let you pick what you need, when you need it, without having to start
        a new poly-Bézier curve.</p>
      </section>

      <section id="shapes">
        <h2>Boolean shape operations</h2>

        <p>We can apply the topics covered so far in this primer to effect boolean shape operations:
        getting the union, intersection, or exclusion, between two or more shapes that involve Bézier
        curves. For simplicity (well.. sort of, more homogeneity), we'll be looking at Poly-Bézier
        shapes only, but a shape that consists of a mix of lines and Bézier curves is technically a
        simplification (although it does mean we need to write a definition for the class of shapes
        that mix lines and Bézier curves. Since poly-Bézier curves are a superset, we'll be using
        those in the following examples)</p>

        <p>The procedure for performing boolean operations consists, broadly, of four steps:</p>

        <ol>
          <li>Find the intersection points between both shapes,</li>
          <li>cut up the shapes into multiple sections between these intersections,</li>
          <li>discard any section that isn't part of the desired operation's resulant shape, and</li>
          <li>link up the remaining sections to form the new shape.</li>
        </ol>

        <p>Finding all intersections between two poly-Bézier curves, or any poly-line-section shape,
        is similar to the iterative algorithm discussed in the section on curve/curve intersection.
        For each segment in the poly-Bézier curve we check whether its bounding box overlaps with
        any of the segment bounding boxes in the other poly-Bézier curve. If so, we run normal
        intersection detection.</p>

        <p>After we found all intersection points, we split up our poly-Bézier curves, making sure to
        record which of the newly formed poly-Bézier curves might potentially link up at the points
        we split the originals up at. This will let us quickly glue poly-Bézier curves back together
        after the next step.</p>

        <p>Once we have all the new poly-Bézier curves, we run the first step of the desired boolean
        operation.</p>

        <ul>
          <li>Union: discard all poly-Bézier curves that lie "inside" our union of our shapes. E.g. if
          we want the union of two overlapping circles, the resulting shape is the outline.</li>
          <li>Intersection: discard all poly-Bézier curves that lie "outside" the intersection of the
          two shapes. E.g. if we want the intersection of two overlapping circles, the resulting
          shape is the tapered ellipse where they overlap.</li>
          <li>Exclusion: none of the sections are discarded, but we will need to link the shapes back
          up in a special way. Flip any section that would qualify for removal under UNION rules.</li>
        </ul>

        <table class="sketch"><tr><td class="labeled-image">
          <img src="images/op_base.gif" height="169px">
          <p>Two overlapping shapes.</p>
        </td><td class="labeled-image">
          <img src="images/op_union.gif" height="169px">
          <p>The unified region.</p>
        </td><td class="labeled-image">
          <img src="images/op_intersection.gif" height="169px">
          <p >Their intersection.</p>
        </td><td class="labeled-image">
          <img src="images/op_exclusion.gif" height="169px">
          <p>Their exclusion regions.</p>
        </td></tr></table>

        <p>The main complication in the outlined procedure here is determining how sections qualify
        in terms of being "inside" and "outside" of our shapes. For this, we need to be able to
        perform point-in-shape detection, for which we'll use a classic algorithm: getting the
        "crossing number" by using ray casting, and then testing for "insidedness" by applying
        the <a href="http://folk.uio.no/bjornw/doc/bifrost-ref/bifrost-ref-12.html">even-odd
        rule</a>: For any point and any shape, we can cast a ray from our point, to some point that we know
        lies outside of the shape (such as a corner of our drawing surface). We then count how many
        times that line crosses our shape (remember that we can perform line/curve intersection
        detection quite easily). If the number of times it crosses the shape's outline is even,
        the point did not actually lie inside our shape. If the number of intersections is odd,
        our point did lie inside out shape. With that knowledge, we can decide whether to treat
        a section that such a point lies on "needs removal" (under union rules), "needs preserving"
        (under intersection rules), or "needs flipping" (under exclusion rules).</p>

        <p>Applying this rule in a simple setting, the following sketch shows whether your cursor's
        coordinate is considered "inside" or "outside" the given outline shape. Try changing the
        outline's shape to see what happens w.r.t. "insidedness", particularly by introducing
        enclosed regions or self-intersecting loops.</p>

        <textarea class="sketch-code" data-sketch-preset="poly" data-sketch-title="Testing 'insidedness'">
        void setupCurve() {
          setupDefaultCubicPoly();
          int pad = dim/3;
          float k = 0.55228;
          p.addCurve(new BezierCurve(new Point[]{
            ORIGIN,
            ORIGIN,
            new Point(dim/2-0.55228*pad, dim/2+pad),
            new Point(dim/2, dim/2+pad)
          }));
          p.close();
        }

        void movePoint(int pt, int mx, int my) {
          p.movePoint(pvt, mx, my);
        }

        void handleMouseMoved(int mx, int my) {
          int cross = p.getCrossingNumber(new Point(mx, my), new Point(0,0));
          if(cross%2==0) {
            p.draw(color(255,0,0));
          } else {
            p.draw(color(0,255,0));
          }
        }
        </textarea>

        <p>So, using this approach we can easily detect which parts of a shape to keep, and which to reject.
        After pruning, we perform the last step: link up all the remaining sections. The following sketch
        shows two shapes as well as the result of applying a union (middle) and intersection (right) operation
        to the pair.</p>

        <textarea class="sketch-code" data-sketch-preset="shapes" data-sketch-title="Performing Boolean shape operations">
        void setupCurve() {
          setupDefaultShapes();
          fill(0);
          textAlign(CENTER);
        }

        void drawShapes() {
          p1.draw(color(200,0,0));
          p2.draw(color(0,200,0));
          text("shapes", dim/2, dim-10);

          nextPanel();
          stroke(0);
          line(0,0,0,dim);
          PolyBezierCurve union = bcomp.getUnion();
          union.draw(color(0,255,0), true);
          text("shape union", dim/2, dim-10);

          nextPanel();
          stroke(0);
          line(0,0,0,dim);
          PolyBezierCurve intersection = bcomp.getIntersection();
          intersection.draw(color(255,0,0), true);
          text("shape intersection", dim/2, dim-10);
        }</textarea>

        <div class="note">
          This sketch is still being fixed up so that it's interactive. Boolean operations are, however,
          fairly expensive operations and as such writing a sketch where you can move things around while
          also performing union/interesction operations within 16ms (the typical frame time at 60fps) or
          even 32ms is pretty much impossible. In plain Processing, it takes about 300ms on my computer,
          which isn't a terribly new computer, but still a fairly competent machine (being an i7 950).
          So for now, this sketch is -unfortunately- not interactive.
        </div>
      </section>

      <section id="projections">
        <h2>Projecting a point onto a Bézier curve</h2>

        <p>Say we have a Bézier curve and some point, not on the curve, of which we want to know which
        <i>t</i> value on the curve gives us an on-curve point closest to our off-curve point. Or: say
        we want to find the projection of a random point onto a curve. How do we do that?</p>

        <p>If the Bézier curve is of low enough order, we might be able to <a href="http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html">work out the math for how
        to do this</a>, and get a perfect <i>t</i> value back, but in general this is an incredibly hard
        problem and the easiest solution is, really, a numerical approach again. We'll be finding our
        ideal <i>t</i> value using a <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary
        search</a>. First, we do a coarse distance-check based on <i>t</i> values associated with the
        curve's "to draw" coordinates (using a lookup table, or LUT). This is pretty fast. Then we run
        this algorithm:</p>

        <ol>
          <li>with the <i>t</i> value we found, start with some small interval around <i>t</i>
          (1/length_of_LUT on either side is a reasonable start),</li>
          <li>if the distance to <i>t ± interval/2</i> is larger than the distance to <i>t</i>,
          try again with the interval reduced to half its original length.</li>
          <li>if the distance to <i>t ± interval/2</i> is smaller than the distance to <i>t</i>,
          replace <i>t</i> with the smaller-distance value.</li>
          <li>after reducing the interval, or changing <i>t</i>, go back to step 1.</li>
        </ol>

        <p>We keep repeating this process until the interval is small enough to claim the difference
        in precision found is irrelevant for the purpose we're trying to find <i>t</i> for. In this
        case, I'm arbitrarily fixing it at 0.0001.</p>

        <p>The following graphic demonstrates the result of this procedure.Simply move the cursor
        around, and if it does not lie on top of the curve, you will see a line that projects the
        cursor onto the curve based on an iteratively found "ideal" <i>t</i> value.</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Projecting a point onto a Bézier curve">
        void setupCurve() {
          int d = dim - 2*pad;
          int order = 10;
          int[] c = {248,188, 218,294, 45,290, 12,236, 14,82, 186,177, 221,90, 18,156, 34,57, 198,18};
          Point[] points = new Point[c.length/2];
          for(int i=0, e=c.length; i<e; i+=2) {
            points[i/2] = new Point(c[i], c[i+1]);
          }
          curves.add(new BezierCurve(points));
          redrawOnMove();
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();

          if(curve.over(mouseX,mouseY) == -1) {
            float t = curve.getPointProjection(new Point(mouseX, mouseY));
            Point p = curve.getPoint(t);
            stroke(255,0,0);
            line(mouseX, mouseY, p.x, p.y);
            fill(150,0,0);
            text("t ≈ " + (int(1000*t)/1000.0), p.x+10, p.y);
            text("p: "+mouseX+"/"+mouseY, mouseX+10, mouseY);
          }
        }</textarea>

      </section>


      <section id="offsetting">
        <h2>Curve offsetting</h2>

        <p>Perhaps you are like me, and you've been writing various small programs that use Bézier curves in some way or another,
        and at some point you make the step to implementing path extrusion. But you don't want to do it pixel based, you want to
        stay in the vector world. You find that extruding lines is relatively easy, and tracing outlines is coming along nicely
        (although junction caps and fillets are a bit of a hassle), and then decide to do things properly and add Bézier curves
        to the mix. Now you have a problem.</p>

        <p>Unlike lines, you can't simply extrude a Bézier curve by taking a copy and moving it around, because of the curvatures;
        rather than a uniform thickness you get an extrusion that looks too thin in places, if you're lucky, but more likely will
        self-intersect. The trick, then, is to scale the curve, rather than simply copying it. But how do you scale a Bézier curve?</p>

        <p>Bottom line: <strong>you can't</strong>. So you cheat. We're not going to do true curve scaling, or rather curve
        offsetting, because that's impossible. Instead we're going to try to generate 'looks good enough' offset curves.</p>

        <div class="note">
          <h2>"What do you mean, you can't. Prove it."</h2>

          <p>First off, when I say "you can't" what I really mean is "you can't offset a Bézier curve with another
          Bézier curve". not even by using a really high order curve. You can find the function that describes the
          offset curve, but it won't be a polynomial, and as such it cannot be represented as a Bézier curve, which
          <strong>has</strong> to be a polynomial. Let's look at why this is:</p>

          <p>From a mathematical point of view, an offset curve <i>O(t)</i> is a curve such that, given our original curve
          <i>B(t)</i>, any point on <i>O(t)</i> is a fixed distance <i>d</i> away from coordinate <i>B(t)</i>.
          So let's math that:</p>

          <p>\[
            O(t) = B(t) + d
          \]</p>

          <p>However, we're working in 2D, and <i>d</i> is a single value, so we want to turn it into a vector. If we
          want a point distance <i>d</i> "away" from the curve <i>B(t)</i> then what we really mean is that we want
          a point at <i>d</i> times the "normal vector" from point <i>B(t)</i>, where the "normal" is a vector
          that runs perpendicular ("at a right angle") to the tangent at <i>B(t)</i>. Easy enough:</p>

          <p>\[
            O(t) = B(t) + d \cdot N(t)
          \]</p>

          <p>Now this still isnt very useful unless we know what the formula for <i>N(t)</i> is, so let's find out.
          <i>N(t)</i> runs perpendicular to the original curve tangent, and we know that the tangent is simply
          <i>B'(t)</i>, so we could just rotate that 90 degrees and be done with it. However, we need to ensure
          that <i>N(t)</i> has the same magnitude for every <i>t</i>, or the offset curve won't be at a uniform
          distance, thus not being an offset curve at all. The easiest way to guarantee this is to make sure
          <i>N(t)</i> always has length 1, which we can achieve by dividing <i>B'(t)</i> by its magnitude:</p>

          <p>\[
            N(t) \perp \left ( \frac{B'(t)}{\left || B'(t) \right || } \right )
          \]</p>

          <p>Determining the length requires computing an arc length, and this is where things get Tricky with
          a capital T. First off, to compute arc length from some start <i>a</i> to end <i>b</i>, we must use
          the formula we saw earlier. Noting that "length" is usually denoted with double vertical bars:</p>

          <p>\[
            \left || f(x,y) \right || = \int^b_a \sqrt{ f_x'^2 + f_y'^2}
          \]</p>

          <p>So if we want the length of the tangent, we plug in <i>B'(t)</i>, with <i>t = 0</i> as start and
          <i>t = 1</i> as end:</p>

          <p>\[
            \left || B'(t) \right || = \int^1_0 \sqrt{ B_x''(t)^2 + B_y''(t)^2}
          \]</p>

          <p>And that's where things go wrong. It doesn't even really matter what the second derivative for <i>B(t)</i>
          is, that square root is screwing everything up, because it turns our nice polynomials into things that are no
          longer polynomials.</p>

          <p>There is a small class of polynomials where the square root is also a polynomial, but
          they're utterly useless to us: any polynomial with unweighted binomial coefficients has a square root that is
          also a polynomial. Now, you might think that Bézier curves are just fine because they do, but they don't;
          remember that only the <strong>base</strong> function has binomial coefficients. That's before we factor
          in our coordinates, which turn it into a non-binomial polygon. The only way to make sure the functions
          stay binomial is to make all our coordinates have the same value. And that's not a curve, that's a point.
          We can already create offset curves for points, we call them circles, and they have much simpler functions
          than Bézier curves.</p>

          <p>So, since the tangent length isn't a polynomial, the normalised tangent won't be a polynomial either, which
          means <i>N(t)</i> won't be a polynomial, which means that <i>d</i> times <i>N(t)</i> won't be a polynomial,
          which means that, ultimately, <i>O(t)</i> won't be a polynomial, which means that even if we can determine the
          function for <i>O(t)</i> just fine (and that's far from trivial!), it simply cannot be represented as a
          Bézier curve.</p>

          <p>And that's one reason why Bézier curves are tricky: there are actually a <i>lot</i> of curvatures that
          cannot be represent with a Bézier curve at all. They can't even model their own offset curves. They're weird
          that way. So how do all those other programs do it? Well, much like we're about to do, they cheat. We're
          going to approximate an offset curve in a way that will look relatively close to what the real offset
          curve would look like, if we could compute it.</p>
        </div>

        <p>So, you cannot offset a Bézier curve perfectly with another Bézier curve, no matter how hight-order you make
        that other Bézier curve. However, we can chop up a curve into "safe" subcurves (where safe means that all the
        control points are always on a single side of the baseline, and the midpoint of the curve at <i>t=0.5</i> is
        roughly in the center of the polygon defined by the curve coordinates) and then point-scale those subcurves
        with respect to the curve's scaling origin (which is the intersection of the point normals at the start
        and end points).</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Offsetting a quadratic Bézier curve">
        void setupCurve() {
          setupDefaultQuadratic();
          offsetting();
          offset = 20;
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();

          if(offset>0) {
            noAdditionals();
            BezierCurve[] offsetCurve = curve.offset(offset);
            for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
            offsetCurve = curve.offset(-offset);
            for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
          }
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Offsetting a cubic Bézier curve">
        void setupCurve() {
          setupDefaultCubic();
          offsetting();
          offset = 20;
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();

          if(offset>0) {
            noAdditionals();
            BezierCurve[] offsetCurve = curve.offset(offset);
            for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
            offsetCurve = curve.offset(-offset);
            for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
          }
        }</textarea>

        <p>You may notice that this may still lead to small 'jumps' in the subcurves when moving the
        curve around. This is caused by the fact that we're still performing a naive form of offsetting,
        moving the control points the same distance as the start and end points. If the curve is large
        enough, this may still lead to incorrect offsets.</p>
      </section>

      <section id="graduatedoffset">
        <h2>Graduated curve offsetting</h2>

        <p>What if we want to do graduated offsetting, starting at some distance <i>s</i> but ending
        at some other distance <i>e</i>? well, if we can compute the length of a curve (which we can
        if we use the Legendre-Gauss quadrature approach) then we can also determine how far "along the
        line" any point on the curve is. With that knowledge, we can offset a curve so that its offset
        curve is not uniformly wide, but graduated between with two different offset widths at the
        start and end.</p>

        <p>Like normal offsetting we cut up our curve in subcurves, and then check at which distance
        along the original curve each subcurve starts and ends, as well as to which point on the curve
        each of the control points map. This gives us the distance-along-the-curve for each interesting
        point in the subcurve. If we call the total length of all subcurves seen prior to seeing "the\
        current" subcurve <i>S</i> (and if the current subcurve is the first one, <i>S</i> is zero),
        and we call the full length of our original curve <i>L</i>, then we get the following graduation
        values:</p>

        <ul>
          <li>start: map <i>S</i> from interval (<i>0,L</i>) to interval <i>(s,e)</i></li>
          <li>c1: <i>map(<strong>S+d1</strong>, 0,L, s,e)</i>, d1 = distance along curve to projection of c1</li>
          <li>c2: <i>map(<strong>S+d2</strong>, 0,L, s,e)</i>, d2 = distance along curve to projection of c2</li>
          <li>...</li>
          <li>end: <i>map(<strong>S+length(subcurve)</strong>, 0,L, s,e)</i></li>
        </ul>

        At each of the relevant points (start, end, and the projections of the control points onto
        the curve) we know the curve's normal, so offsetting is simply a matter of taking our original
        point, and moving it along the normal vector by the offset distance for each point. Doing so
        will give us the following result (these have with a starting width of 0, and an end width
        of 40 pixels, but can be controlled with your + and - keys):</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Graduated offsetting a quadratic Bézier curve">
        void setupCurve() {
          setupDefaultQuadratic();
          offsetting();
          offset = 20;
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();
          if(offset>0) {
            noAdditionals();
            BezierCurve[] offsetCurve = curve.offset(offset, 0, 1);
            for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
            offsetCurve = curve.offset(-offset, 0, 1);
            for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
          }
        }</textarea>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Graduated offsetting a cubic Bézier curve">
        void setupCurve() {
          setupDefaultCubic();
          offsetting();
          offset = 20;
        }

        void drawCurve(BezierCurve curve) {
          additionals();
          curve.draw();
          if(offset>0) {
            noAdditionals();
            BezierCurve[] offsetCurve = curve.offset(offset, 0, 1);
            for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
            offsetCurve = curve.offset(-offset, 0, 1);
            for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
          }
        }</textarea>
      </section>

      <section id="circles">
        <h2>Circles and quadratic Bézier curves</h2>

        <p>Circles and Bézier curves are very different beasts, and circles are infinitely easier
        to work with than Bézier curves. Their formula is much simpler, and they can be drawn more
        efficiently. But, sometimes you don't have the luxury of using circles, or ellipses, or
        arcs. Sometimes, all you have are Bézier curves. For instance, if you're doing font design,
        fonts have no concept of geometric shapes, they only know straight lines, and Bézier curves.
        OpenType fonts with TrueType outlines only know quadratic Bézier curves, and OpenType fonts
        with Type2 outlines only know cubic Bézier curves. So how do you draw a circle, or an ellipse,
        or an arc?</p>

        <p>You approximate.</p>

        <p>We already know that Bézier curves cannot model all curves that we can think of, and
        this includes perfect circles, as well as ellipses, and their arc counterparts. However,
        we can certainly approximate them to a degree that is visually acceptable. Quadratic and cubic
        curves offer us different curvature control, so in order to approximate a circle we will
        first need to figure out what the error is if we try to approximate arcs of increasing degree
        with quadratic and cubic curves, and where the coordinates even lie.</p>

        <p>Since arcs are mid-point-symmetrical, we need the control points to set up a symmetrical
        curve. For quadratic curves this means that the control point will be somewhere on a line
        that intersects the baseline at a right angle. And we don't get any choice on where that
        will be, since the derivatives at the start and end point have to line up, so our control
        point will lie at the intersection of the tangets at the start and end point.</p>

        <p>First, let's try to fit the quadratic curve onto a circular arc. In the following sketch
        you can move the mouse around over a unit circle, to see how well, or poorly, a quadratic
        curve can approxiate the arc from (1,0) to where your mouse cursor is:</p>

        <textarea class="sketch-code" data-sketch-preset="arcfitting" data-sketch-title="Quadratic Bézier arc approximation">
        void setupCurve() { order = 2; }

        void checkConnect() {
          if((s==0 && e>PI/2) || s<-PI/2) { connect(); }
          else { noConnect(); }
        }

        void findArcFitting() {
          Point[] points = {
            new Point(dim/2 + dim/f2, dim/2),
            new Point(dim/2, dim/2),
            new Point(dim/2 + dim/f2*cos(ax), dim/2 + dim/f2*sin(ay))
          };
          Point c = comp.lli(new Point[]{
            points[0],
            new Point(points[0].x, points[0].y + 10),
            points[2],
            new Point(points[2].x + dx, points[2].y + dy)
          });
          points[1] = c;
          BezierCurve bc = new BezierCurve(points);
          bc.draw();
          bc.getPoint(0.5).draw();
        }</textarea>

        <p>As you can see, things go horribly wrong quite quickly; even trying to approximate a quarter circle
        using a quadratic curve is a bad idea. An eighth of a turns might look okay, but how okay is okay?
        Let's apply some math and find out. What we're interested in is how far off our on-curve coordinates
        are with respect to a circular arc, given a specifc start and end angle. We'll be looking at how much
        space there is between the circular arc, and the quadratic curve's midpoint.</p>

        <p>We start out with our start and end point, and for convenience we will place them on a unit
        circle (a circle around 0,0 with radius 1), at some angle <i>φ</i>:</p>

        <p>\[ S = \begin{pmatrix} 1 \\ 0 \end{pmatrix} \ , \ \  E = \begin{pmatrix} cos(φ) \\ sin(φ) \end{pmatrix} \]</p>

        <p>What we want to find is the intersection of the tangents, so we want a point C such that:</p>

        <p>\[ C = S + a \cdot \begin{pmatrix} 0 \\ 1 \end{pmatrix} \ , \ \ C = E + b \cdot \begin{pmatrix} -sin(φ) \\ cos(φ) \end{pmatrix} \]</p>

        <p>i.e. we want a point that lies on the vertical line through A (at some distance <i>a</i>
        from A) and also lies on the tangent line through B (at some distance <i>b</i> from B). Solving
        this gives us:</p>

        <p>\[ \left\{ \begin{array}{l}
          C_x = 1 = cos(φ) + b \cdot -sin(φ)\\
          C_y = a = sin(φ) + b \cdot cos(φ)
        \end{array} \right. \]</p>

        <p>First we solve for <i>b</i>:</p>

        <p>\[ \begin{array}{l}
          1 = cos(φ) + b \cdot -sin(φ) \ → \
          1 - cos(φ) = -b \cdot sin(φ) \ → \
          -1 + cos(φ) = b \cdot sin(φ) \\ \\
          b = \frac{-1 + cos(φ)}{sin(φ)}
        \end{array} \]</p>

        <p>which we can then substitute in the expression for <i>a</i>:</p>

        <p>\[ \begin{align*}
          a &= sin(φ) + b \cdot cos(φ) \\
          .. &= sin(φ) + \frac{-1 + cos(φ)}{sin(φ)} \cdot cos(φ) \\
          .. &= sin(φ) + \frac{-cos(φ) + cos^2(φ)}{sin(φ)} \\
          .. &= \frac{sin^2(φ) + cos^2(φ) - cos(φ)}{sin(φ)} \\
          a &= \frac{1 - cos(φ)}{sin(φ)}
        \end{align*} \]</p>

        <p>A quick check shows that plugging these values for <i>a</i> and <i>b</i> into the expressions
        for C<sub>x</sub> and C<sub>y</sub> give the same x/y coordinates for both "<i>a</i> away from A"
        and "<i>b</i> away from B", so let's continue: now that we know the coordinate values for C, we
        know where our on-curve point T for <i>t=0.5</i> (or angle φ/2) is, because we can just evaluate
        the Bézier polynomial, and we know where the circle arc's actual point P is for angle φ/2:</p>

        <p>\[
          P_x = cos(\frac{φ}{2}) \ , \ \  P_y = sin(\frac{φ}{2})
        \]</p>

        <p>We compute T, observing that if <i>t=0.5</i>, the polynomial values (1-t)², 2(1-t)t, and t²
        are 0.25, 0.5, and 0.25 respectively:</p>

        <p>\[\begin{array}{l}
          T = \frac{1}{4}S + \frac{2}{4}C + \frac{1}{4}E = \frac{1}{4}(S + 2C + E) \\

          = \

          \left\{\begin{align*}
          T_x &= \frac{1}{4}(3 + cos(φ))\\
          T_y &= \frac{1}{4}\left(\frac{2-2cos(φ)}{sin(φ)} + sin(φ)\right)
               = \frac{1}{4}\left(2tan\left(\frac{φ}{2}\right) + sin(φ)\right)
          \end{align*}\right.
        \end{array}\]</p>

        <p>And the distance between these two is the standard Euclidean distance:</p>

        <p>\[\begin{array}{l}
          d_x(φ) = T_x - P_x = \frac{1}{4}(3 + cos(φ)) - cos(\frac{φ}{2}) = 2sin^4\left(\frac{φ}{4}\right) \ , \\
          d_y(φ) = T_y - P_y = \frac{1}{4}\left(2tan\left(\frac{φ}{2}\right) + sin(φ)\right) - sin(\frac{φ}{2}) \ , \\
          d(φ) = \sqrt{d^2_x + d^2_y} = \ ... \  = 2sin^4(\frac{φ}{2})\sqrt{\frac{1}{cos^2(\frac{φ}{2})}}
        \end{array}\]</p>

        <p>So, what does this distance function look like when we plot it for a
        number of ranges for the angle φ, such as a half circle, quarter circle and eighth circle?</p>

        <table><tr><td>
          <p><a href="http://www.wolframalpha.com/input/?i=plot+sqrt%28%281%2F4+*+%28sin%28x%29+%2B+2tan%28x%2F2%29%29+-+sin%28x%2F2%29%29%5E2+%2B+%282sin%5E4%28x%2F4%29%29%5E2%29+for+0+%3C%3D+x+%3C%3D+pi"><img
          src="images/arc-q-pi.gif"
          ></a></p>
          <p>plotted for 0 ≤ φ ≤ π:</p>
        </td><td>
          <p><a href="http://www.wolframalpha.com/input/?i=plot+sqrt%28%281%2F4+*+%28sin%28x%29+%2B+2tan%28x%2F2%29%29+-+sin%28x%2F2%29%29%5E2+%2B+%282sin%5E4%28x%2F4%29%29%5E2%29+for+0+%3C%3D+x+%3C%3D+pi%2F2"><img
          src="images/arc-q-pi2.gif"></a></p>
          <p>plotted for 0 ≤ φ ≤ ½π:</p>
        </td><td>
          <p><a href="http://www.wolframalpha.com/input/?i=plot+sqrt%28%281%2F4+*+%28sin%28x%29+%2B+2tan%28x%2F2%29%29+-+sin%28x%2F2%29%29%5E2+%2B+%282sin%5E4%28x%2F4%29%29%5E2%29+for+0+%3C%3D+x+%3C%3D+pi%2F4"><img
          src="images/arc-q-pi4.gif"></a></p>
          <p>plotted for 0 ≤ φ ≤ ¼π:</p>
        </td></tr></table>

        <p>We now see why the eighth circle arc looks decent, but the quarter circle arc doesn't:
        an error of roughly 0.06 at <i>t=0.5</i> means we're 6% off the mark... we will already be
        off by one pixel on a circle with pixel radius 17. Any decent sized quarter circle arc, say
        with radius 100px, will be way off if approximated by a quadratic curve! For the eighth
        circle arc, however, the error is only roughly 0.003, or 0.3%, which explains why it looks
        so close to the actual eighth circle arc. In fact, if we want a truly tiny error, like 0.001,
        we'll have to contend with an angle of (rounded) 0.593667, which equates to roughly 34 degrees.
        We'd need 11 quadratic curves to form a full circle with that precision! (technically,
        10 and ten seventeenth, but we can't do partial curves, so we have to round up). That's a
        whole lot of curves just to get a shape that can be drawn using a simple function!</p>

        <p>In fact, let's flip the function around, so that if we plug in the precision error, labeled
        ε, we get back the maximum angle for that precision:</p>

        <p>\[
          φ = 4 \cdot arccos \left(\frac{\sqrt{2+ε-\sqrt{ε(2+ε)}}}{\sqrt{2}}\right)
        \]</p>

        <p>Things are starting to look, frankly, a bit ridiculous at this point, but this is as far
        as we need the math to take us. If we plug in the precisions 0.1, 0.01, 0.001 and 0.0001 we
        get the values 1.748, 1.038, 0.594 and 0.3356; in degrees, roughly 100 (requiring four curves),
        59.5 (requiring six curves), 34 (requiring 11 curves), and 19.2 (requiring a whopping nineteen
        curves). </p>

        <p>The bottom line? <strong>Quadratic curves are kind of lousy</strong>, if you want circular
        (or elliptical, which are circles that have been squashed in one dimension) curvatures. We
        can do better, even if it's just by raising the order of our curve once. So let's try the
        same thing for cubic curves.</p>
      </section>

      <section id="circles_cubic">
        <h2>Circles and cubic Bézier curves</h2>

        <p>For cubic curves the control points must be each other's mirror around the line running
        through the baseline midpoint, at a right angle, and again the derivatives at the start and
        end points must agree. Again we don't have altogether that much choice: there is only one
        pair of control points that guarantees correct derivatives for the start and end points,
        while also making the midpoint of the curve lie on top of the curve.</p>

        <p>In order to find a cubic curve, we first "guess" the curve, based on the previously outlined
        curve-through-three-points procedure. This will give use a curve with correct start, mid and
        end points, but incorrect derivatives for start and end, given the control points. We then
        slide the control points along the line that connects them until they effect the corrected
        derivative at the start and end points (you may remember that the derivative at the start
        is aligned with the line from start point to control point 1, and that the derivative at the
        end is aligned with the line from control point 2 to the end point).</p>

        <textarea class="sketch-code" data-sketch-preset="arcfitting" data-sketch-title="Cubic Bézier arc approximation">
        void setupCurve() { order = 3; }

        void checkConnect() {
          if(e < PI) { noConnect(); } else { connect(); }
        }

        void findArcFitting() {
          // guess the curve based on the start/mid/end points:
          Point p1 = new Point(dim/2 + dim/f2,dim/2),
                p2 = new Point(dim/2 + dim/f2*cos((s+e)/2), dim/2 + dim/f2*sin((s+e)/2)),
                p3 = new Point(dim/2 + dim/f2*cos(ax), dim/2 + dim/f2*sin(ay));
          BezierCurve guess = comp.generateCurve(3,p1,p2,p3);

          Point oc1 = guess.points[1];

          drawGuess(guess);

          // then, move the control points so that B'(0) and B'(1) are correct:
          Point c1 = comp.lli(new Point[]{
            guess.points[0],
            new Point(p1.x, p1.y+10),
            guess.points[1],
            guess.points[2],
          });

          // taking advantage of symmetry, we trivially know c2 now, too:
          dx = guess.points[1].x - c1.x;
          dy = guess.points[1].y - c1.y;
          Point c2 = new Point(guess.points[2].x + dx,
                               guess.points[2].y + dy);

          // replace, update, and draw.
          guess.points[1] = c1;
          guess.points[2] = c2;
          guess.update();
          guess.draw();

          float a = 0.211325;
          Point pa = guess.getPoint(a);
          pa.draw();
          guess.getPoint(1-a).draw();
        }</textarea>

        <p>We see two curves here; very faintly the "guessed" curve, and drawn normally, the proper curve
        with the control points shifted along the control line so that the derivatives at the start and end
        points are correct. With this, we can see that cubic curves are actually a lot better than quadratic
        curves, and don't look all that wrong until we go past a quarter circle; ⅜th starts to hint at
        problems, and half a circle has an obvious "gap" between the real circle and the cubic approximation.
        Anything past that just looks plain ridiculous... but quarter curves actually look pretty okay!
        Again, how okay is okay? Let's apply some more math to find out.</p>

        <p>Unlike for the quadratic curve, we can't use <i>t=0.5</i> as our reference point because by its
        very nature it's one of the three points that are actually guaranteed to lie on the circular curve.
        Instead, we need a different <i>t</i> value. If we run some analysis on the curve we find that the
        actual <i>t</i> value at which the curve is furthest from what it should be is 0.211325 (rounded),
        but we don't know "why", since finding this value involves root-finding, and is nearly impossible
        to do symbolically without pages and pages of math just to express one of the possible solutions.</p>

        <p>So instead, let's simply take that <i>t</i> value and see what the error is for circular arcs
        with an angle ranging from 0 to 2π:</p>

        <table><tr><td>
          <p><img src="images/arc-c-2pi.gif"></p>
          <p>plotted for 0 ≤ φ ≤ 2π:</p>
        </td><td>
          <p><img src="images/arc-c-pi.gif"></p>
          <p>plotted for 0 ≤ φ ≤ π:</p>
        </td><td>
          <p><img src="images/arc-c-pi2.gif"></p>
          <p>plotted for 0 ≤ φ ≤ ½π:</p>
        </td></tr></table>

        <p>We see that cubic Bézier curves are much better when it comes to approximating circular arcs,
        with an error of less than 0.027 at the two "bulge" points for a quarter circle (which had an
        error of 0.06 for quadratic curves at the mid point), and an error near 0.001 for an eighth
        of a circle, so we're getting less than half the error for a quarter circle, or: at a slightly
        lower error, we're getting twice the arc. This makes cubic curves quite useful.
        In fact, the precision of a cubic curve at a quarter circle is considered "good enough" by many
        to justify using four cubic Bézier curves to fake a full circle when no circle primitives are
        available; generally, people will not notice it's not a real circle unless you overlay the
        actual circle so they can see the difference.</p>

        <p>So if we want to use a cubic Bézier curve, where do the curve's points go?
        The start and end point are the same as before:</p>

        <p>\[ S = \begin{pmatrix} 1 \\ 0 \end{pmatrix} \ , \ \  E = \begin{pmatrix} cos(φ) \\ sin(φ) \end{pmatrix} \]</p>

        <p>But we now need to find two control points, rather than one:</p>

        <p>\[
          C_1 = S + a \cdot \begin{pmatrix} 0 \\ 1 \end{pmatrix} \ \ , \ \
          C_2 = E + b \cdot \begin{pmatrix} -sin(φ) \\ cos(φ) \end{pmatrix}
        \]</p>

        <p>Unlike for the quadratic case, we need some more information in order to compute <i>a</i> and <i>b</i>,
        since they're no longer dependent variables. First, we observe that the curve is symmetrical, so whatever
        values we end up finding for C<sub>1</sub> will apply to C<sub>2</sub> as well (rotated along its tangent),
        so we'll focus on finding the location of C<sub>1</sub> only. So here's where we do something that you might
        not expect: we're going to ignore for a moment, because we're going to have a much easier time if we just
        solve this problem with geometry first, then move to calculus to solve a much simpler problem.</p>

        <p>If we look at the triangle that is formed between our starting point, or initial guess C<sub>1</sub>
        and our real C<sub>1</sub>, there's something funny going on: if we treat the line {start,guess} as
        our opposite side, the line {guess,real} as our adjacent side, with {start,real} our hypothenuse, then
        the angle for the corner hypothenuse/adjacent is half that of the arc we're convering. Try it: if you
        place the end point at a quarter circle (pi/2, or 90 degrees), the angle in our triangle is half a
        quarter (pi/4, or 45 degrees). With that knowledge, and a knowledge of what the length of any of
        our lines segments are (as a function), we can determine where our control points are, and thus have
        everything we need to find the error distance function. Of the three lines, the one we can easiest
        determine is {start,guess}, so let's find out what the guessed control point is. Again geometrically,
        because we have the benefit of an on-curve <i>t=0.5</i> value.</p>

        <p>The distance from our guessed point to the start point is exactly the same as the projection distance
        we looked at earlier. Using <i>t=0.5</i> as our point "B" in the "A,B,C" projection, then we know the
        length of the line segment {C,A}, since it's d<sub>1</sub> = {A,B} + d<sub>2</sub> = {B,C}:</p>

        <p>\[
          ||{A,C}|| = d_2 + d_1 = d_2 + d_2 \cdot ratio_3 \left(\frac{1}{2}\right) = d_2 + \frac{1}{3}d_2 = \frac{4}{3}d_2
        \]</p>

        <p>So that just leaves us to find the distance from <i>t=0.5</i> to the baseline for an arbitrary
        angle φ, which is the distance from the center of the circle to our <i>t=0.5</i> point, minus the
        distance from the center to the line that runs from start point to end point. The first is the
        same as the point P we found for the quadratic curve:</p>

        <p>\[
          P_x = cos(\frac{φ}{2}) \ , \ \  P_y = sin(\frac{φ}{2})
        \]</p>

        <p>And the distance from the origin to the line start/end is another application of angles,
        since the triangle {origin,start,C} has known angles, and two known sides. We can find
        the length of the line {origin,C}, which lets us trivially compute the coordinate for C:</p>

        <p>\[\begin{array}{l}
          l = cos(\frac{φ}{2}) \ , \\
          \left\{\begin{array}{l}
            C_x = l \cdot cos\left(\frac{φ}{2}\right) = cos^2\left(\frac{φ}{2}\right)\ , \\
            C_y = l \cdot sin\left(\frac{φ}{2}\right) = cos(\frac{φ}{2}) \cdot sin\left(\frac{φ}{2}\right)\ , \\
          \end{array}\right.
        \end{array}\]</p>

        <p>With the coordinate C, and knowledge of coordinate B, we can determine coordinate A, and get a vector
        that is identical to the vector {start,guess}:</p>

        <p>\[\left\{\begin{array}{l}
          B_x - C_x = cos\left(\frac{φ}{2}\right) - cos^2\left(\frac{φ}{2}\right) \\
          B_y - C_y = sin\left(\frac{φ}{2}\right) - cos(\frac{φ}{2}) \cdot sin\left(\frac{φ}{2}\right)
                    = sin\left(\frac{φ}{2}\right) - \frac{sin(φ)}{2}
        \end{array}\right.\]</p>

        <p>\[\left\{\begin{array}{l}
          \vec{v}_x = \{C,A\}_x = \frac{4}{3} \cdot (B_x - C_x) \\
          \vec{v}_y = \{C,A\}_y = \frac{4}{3} \cdot (B_y - C_y)
        \end{array}\right.\]</p>

        <p>Which means we can now determine the distance {start,guessed}, which is the same as the distance
          {C,A}, and use that to determine the vertical distance from our start point to our C<sub>1</sub>:</p>

        <p>\[\left\{\begin{array}{l}
          C_{1x} = 1 \\
          C_{1y} = \frac{d}{sin\left(\frac{φ}{2}\right)}
                 = \frac{\sqrt{\vec{v}^2_x + \vec{v}^2_y}}{sin\left(\frac{φ}{2}\right)}
                 = \frac{4}{3} tan \left( \frac{φ}{4} \right)
        \end{array}\right.\]</p>

        <p>And after this tedious detour to find the coordinate for C<sub>1</sub>, we can find C<sub>2</sub>
        fairly simply, since it's lies at distance -C<sub>1y</sub> along the end point's tangent:</p>

        <p>\[\begin{array}{l}
          E'_x = -sin(φ) \ , \ E'_y = cos(φ) \ , \ ||E'|| = \sqrt{ (-sin(φ))^2 + cos^2(φ)} = 1 \ , \\
          \left\{\begin{array}{l}
            C_2x = E_x - C_{1y} \cdot \frac{E_x'}{||E'||}
                 = cos(φ) + C_{1y} \cdot sin(φ)
                 = cos(φ) + \frac{4}{3} tan \left( \frac{φ}{4} \right) \cdot sin(φ) \\
            C_2y = E_y - C_{1y} \cdot \frac{E_y'}{||E'||}
                 = sin(φ) - C_{1y} \cdot cos(φ)
                 = sin(φ) - \frac{4}{3} tan \left( \frac{φ}{4} \right) \cdot cos(φ)
          \end{array}\right.
        \end{array}\]</p>

        <p>And that's it, we have all four points now for an arbitary circular arc with angle φ.
        To make life just that little bit easier, I'll also throw in the standard coordinates
        if you want to approximate a circle with cubic Bézier curves, assuming a unit circle:</p>

        <p>\[\begin{array}{l}
          S = (1, 0) \ , \
          C_1 = \left ( 1, \frac{4\sqrt{2}-4}{3} ≈ 0.55228 \right ) \ , \
          C_2 = \left ( \frac{4\sqrt{2}-4}{3} ≈ 0.55228 , 1 \right ) \ , \
          E = (0, 1)

        \end{array}\]</p>

        <p>Forming the full curve is then a matter of mirroring these coordinates about the origin:</p>

        <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Cubic Bézier circle approximation">
        void setupCurve() {
          setupDefaultCubic();
          noLabels();
        }

        void drawCurve(BezierCurve curve) {
          float ox = dim/2, oy = dim/2, r = dim/2.5;

          stroke(150);
          line(0,dim/2,dim,dim/2);
          line(dim/2,0,dim/2,dim);

          (new BezierCurve(new Point[]{
            new Point(ox + r*1,       oy + r*0),
            new Point(ox + r*1,       oy + r*0.55228),
            new Point(ox + r*0.55228, oy + r*1),
            new Point(ox + r*0,       oy + r*1)
          })).draw();

          (new BezierCurve(new Point[]{
            new Point(ox + r*0,       oy + r*1),
            new Point(ox - r*0.55228, oy + r*1),
            new Point(ox - r*1,       oy + r*0.55228),
            new Point(ox - r*1,       oy + r*0)
          })).draw();

          (new BezierCurve(new Point[]{
            new Point(ox - r*1,       oy + r*0),
            new Point(ox - r*1,       oy - r*0.55228),
            new Point(ox - r*0.55228, oy - r*1),
            new Point(ox + r*0,       oy - r*1)
          })).draw();

          (new BezierCurve(new Point[]{
            new Point(ox + r*0,       oy - r*1),
            new Point(ox + r*0.55228, oy - r*1),
            new Point(ox + r*1,       oy - r*0.55228),
            new Point(ox + r*1,       oy + r*0)
          })).draw();
        }</textarea>
      </section>

      <hr>

      <section id="issues">
        <h2>Todo list</h2>

<!--
        This custom element will be used instead of a 'comment section', so that questions
        get pulled straight from the github issue tracker.

        <github-issues owner="Pomax" repo="bezierinfo"></github-issues>
-->

        <ol>
          <li>Approximating Bezier curves with (elliptical?) arcs</li>
          <li>Programming tricks for fast curves</li>
          <li>Possibly: conversion to, and from, Catmull-Rom splines</li>
          <li>A reference and further reading section</li>
        </ol>

        <p>If there's anything missing from this list, please file an issue on github (link's in the
        upper right corner), and I'll add it to this list (while I write up some code to cleanly
        pull in gh-issues as a 'comment feed'... probbaly using web components).</p>
      </section>
    </article>

    <div id="scriptblock">
      <!-- scripts can come last so they don't hold up the DOM -->
      <script>localStorage.clear();sessionStorage.clear();</script>
      <script src="autonav.js"></script>
      <script src="autolabel.js"></script>
      <script src="sketchloader.js"></script>
      <script src="processing.patched.js"></script>
      <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          displayAlign: "left",
          displayIndent: "2em",
        });
      </script>
      <script>(function(){
        if(window.location.toString().indexOf("noMathJax")===-1) {
          var script = document.createElement("script");
          script.src = "http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML";
          document.head.appendChild(script);
        }
      }());</script>
      <!--
      <script src="webcomponents/web-components.js"></script>
      <script src="webcomponents/custom-elements.js"></script>
      -->
      <script>
        document.addEventListener("DOMContentLoaded", function(){
          Socialite.load("#sharebuttons");
          document.querySelector("#sharebuttons").style.opacity = 1;
        }, false);
      </script>
    </div>
  </body>
</html>
